diff --git a/Android.mk b/Android.mk
index a4f586e..532069d 100644
--- a/Android.mk
+++ b/Android.mk
@@ -5,3 +5,4 @@ ifeq ($(TARGET_DEVICE),apollo_lite)
 include $(call all-makefiles-under,$(LOCAL_PATH))
 
 endif
+
diff --git a/AndroidBoard.mk b/AndroidBoard.mk
index 9c4402d..8e7b79f 100644
--- a/AndroidBoard.mk
+++ b/AndroidBoard.mk
@@ -4,4 +4,3 @@ include $(CLEAR_VARS)
 
 ALL_PREBUILT += $(INSTALLED_KERNEL_TARGET)
 
-# include the non-open-source counterpart to this file
diff --git a/AndroidProducts.mk b/AndroidProducts.mk
index 2741001..f1d6f87 100644
--- a/AndroidProducts.mk
+++ b/AndroidProducts.mk
@@ -1,2 +1,2 @@
-PRODUCT_MAKEFILES := \
-    $(LOCAL_DIR)/lineage.mk
+PRODUCT_MAKEFILES := $(LOCAL_DIR)/lineage.mk
+
diff --git a/BoardConfig.mk b/BoardConfig.mk
index be663a4..eba1105 100644
--- a/BoardConfig.mk
+++ b/BoardConfig.mk
@@ -1,39 +1,49 @@
-# mt6797 platform boardconfig
 LOCAL_PATH := device/vernee/apollo_lite
 
-# Device board elements
-include $(LOCAL_PATH)/board/*.mk
 
-# Disable memcpy opt (for audio libraries)
-TARGET_CPU_MEMCPY_OPT_DISABLE := true
+# BoardConfig for Vernee Apollo Lite with MediaTek Helio X20 (MT6797)
 
-# EGL
-BOARD_EGL_CFG := $(LOCAL_PATH)/configs/egl.cfg
-USE_OPENGL_RENDERER := true
-BOARD_EGL_WORKAROUND_BUG_10194508 := true
 
-# Flags
-BOARD_GLOBAL_CFLAGS += -DNO_SECURE_DISCARD
-TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK := true
+# Architecture Extensions
+ARCH_ARM_HAVE_TLS_REGISTER := true
+ARCH_ARM_HAVE_NEON := true
+ARCH_ARM_HAVE_VFP := true
 
-# Fonts
-EXTENDED_FONT_FOOTPRINT := true
+# Ashmem
+DISABLE_ASHMEM_TRACKING := true
 
-# Platform
-TARGET_BOARD_PLATFORM := mt6797
-TARGET_NO_BOOTLOADER := true
-TARGET_NO_FACTORYIMAGE := true
+# Audio
+BOARD_USES_MTK_AUDIO := true
+USE_XML_AUDIO_POLICY_CONF := 1
+
+# BLOCK_BASED_OTA
+BLOCK_BASED_OTA := true
+
+# Bluetooth
+MTK_BT_SUPPORT := yes
+BOARD_HAVE_BLUETOOTH := true
+BOARD_HAVE_BLUETOOTH_MTK := true
+BOARD_BLUETOOTH_DOES_NOT_USE_RFKILL := true
+BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR := $(LOCAL_PATH)/bluetooth
+
+# Bootanimation
+TARGET_BOOTANIMATION_MULTITHREAD_DECODE := true
+
+# Camera
+USE_CAMERA_STUB := true
+
+# CM hardware
+BOARD_HARDWARE_CLASS := $(LOCAL_PATH)/cmhw
 
 # CPU
+# 2x Cortex-A72 @ 2.31GHz
+# 4x Cortex-A53 @ 1.85GHz
+# 4x Cortex-A53 @ 1.39GHz
 TARGET_ARCH := arm64
 TARGET_ARCH_VARIANT := armv8-a
 TARGET_CPU_ABI := arm64-v8a
 TARGET_CPU_ABI2 :=
 TARGET_CPU_VARIANT := cortex-a53
-# Device haves a combination of cortex a72 + cortex a53
-#2x Cortex-A72 @ 2.1GHz ~ 2.3GHz
-#4x Cortex-A53 @ 1.85GHz
-#4x Cortex-A53 @ 1.4GHz
 TARGET_CPU_SMP := true
 
 TARGET_2ND_ARCH := arm
@@ -45,9 +55,40 @@ TARGET_BOARD_SUFFIX := _64
 TARGET_USES_64_BIT_BINDER := true
 
 TARGET_CPU_CORTEX_A53 := true
-
 TARGET_BOOTLOADER_BOARD_NAME := mt6797
 
+# Display
+TARGET_SCREEN_HEIGHT := 1920
+TARGET_SCREEN_WIDTH := 1080
+
+NUM_FRAMEBUFFER_SURFACE_BUFFERS := 3
+TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK := true
+TARGET_FORCE_HWC_FOR_VIRTUAL_DISPLAYS := true
+MAX_VIRTUAL_DISPLAY_DIMENSION := 1
+PRESENT_TIME_OFFSET_FROM_VSYNC_NS := 0
+MTK_HWC_SUPPORT := yes
+MTK_HWC_VERSION := 1.4.1
+TARGET_REQUIRES_SYNCHRONOUS_SETSURFACE := true
+
+# EGL
+BOARD_EGL_CFG := $(LOCAL_PATH)/configs/egl.cfg
+USE_OPENGL_RENDERER := true
+BOARD_EGL_WORKAROUND_BUG_10194508 := true
+
+# Flags
+BOARD_GLOBAL_CFLAGS += -DNO_SECURE_DISCARD
+TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK := true
+
+# Fonts
+EXTENDED_FONT_FOOTPRINT := true
+
+# GPS
+BOARD_MEDIATEK_USES_GPS := true
+BOARD_GPS_LIBRARIES := true
+
+# Header Path
+TARGET_SPECIFIC_HEADER_PATH += $(DEVICE_PATH)/include
+
 # Kernel
 TARGET_USES_64_BIT_BINDER := true
 TARGET_IS_64_BIT := true
@@ -63,14 +104,25 @@ TARGET_KERNEL_CROSS_COMPILE_PREFIX := aarch64-linux-android-
 MTK_APPENDED_DTB_SUPPORT := yes
 BOARD_KERNEL_IMAGE_NAME := Image.gz-dtb
 
-# BLOCK_BASED_OTA
-BLOCK_BASED_OTA := true
+# Legacy Blobs
+TARGET_NEEDS_PLATFORM_TEXT_RELOCATIONS := true
+
+# LightHAL
+TARGET_PROVIDES_LIBLIGHT := true
+
+# MEMCPY
+TARGET_CPU_MEMCPY_OPT_DISABLE := true
+
+# MTK Hardware
+BOARD_HAS_MTK_HARDWARE := true
+BOARD_USES_MTK_HARDWARE := true
+MTK_HARDWARE := true
 
 # NINJA
 USE_NINJA := true
 
 # Partitions
-BOARD_BOOTIMAGE_PARTITION_SIZE := 16777216#20971520
+BOARD_BOOTIMAGE_PARTITION_SIZE := 16777216
 BOARD_RECOVERYIMAGE_PARTITION_SIZE := 16777216
 BOARD_SYSTEMIMAGE_PARTITION_SIZE := 2684354560                                    
 BOARD_USERDATAIMAGE_PARTITION_SIZE := 1107296256
@@ -81,20 +133,32 @@ BOARD_FLASH_BLOCK_SIZE := 4096
 BOARD_HAS_LARGE_FILESYSTEM := true
 TARGET_USERIMAGES_USE_EXT4 := true
 
-# Display
-TARGET_SCREEN_HEIGHT := 1920
-TARGET_SCREEN_WIDTH := 1080
+# Platform
+TARGET_BOARD_PLATFORM := mt6797
+TARGET_NO_BOOTLOADER := true
+TARGET_NO_FACTORYIMAGE := true
 
-# LightHAL
-TARGET_PROVIDES_LIBLIGHT := true
+# Recovery
+BOARD_HAS_NO_SELECT_BUTTON := true
+TARGET_RECOVERY_FSTAB := $(LOCAL_PATH)/rootdir/recovery.fstab
+
+# RIL
+BOARD_RIL_CLASS := ยง(LOCAL_PATH)/ril
+BOARD_CONNECTIVITY_MODULE := conn_soc
+
+# SEccomp
+BOARD_SECCOMP_POLICY := $(LOCAL_PATH)/seccomp
+
+# SELinux
+BOARD_SEPOLICY_DIRS := $(LOCAL_PATH)/sepolicy
 
 # Sensors
 TARGET_NO_SENSOR_PERMISSION_CHECK := true
 
-# Recovery
-BOARD_HAS_NO_SELECT_BUTTON := true
-TARGET_RECOVERY_FSTAB := $(LOCAL_PATH)/rootdir/recovery.fstab
-# TWRP-specific
+# System.prop
+TARGET_SYSTEM_PROP := $(LOCAL_PATH)/system.prop
+
+# TWRP
 ifeq ($(RECOVERY_VARIANT), twrp)
 DEVICE_RESOLUTION := 1080x1920
 DEVICE_SCREEN_WIDTH := 1080
@@ -107,15 +171,14 @@ TW_EXTERNAL_STORAGE_MOUNT_POINT := "external_sd"
 TW_DEFAULT_EXTERNAL_STORAGE := true
 endif
 
-# Include
-TARGET_SPECIFIC_HEADER_PATH += $(DEVICE_PATH)/include
-
-TARGET_SYSTEM_PROP := $(LOCAL_PATH)/system.prop
-
-# SELinux
-BOARD_SEPOLICY_DIRS := \
-       $(LOCAL_PATH)/sepolicy
-
-# Seccomp filter
-BOARD_SECCOMP_POLICY := $(LOCAL_PATH)/seccomp
+# WIFI
+WPA_SUPPLICANT_VERSION := VER_0_8_X
+BOARD_HOSTAPD_DRIVER := NL80211
+BOARD_HOSTAPD_PRIVATE_LIB := lib_driver_cmd_mt66xx
+BOARD_WPA_SUPPLICANT_DRIVER := NL80211
+BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_mt66xx
+WIFI_DRIVER_FW_PATH_PARAM := "/dev/wmtWifi"
+WIFI_DRIVER_FW_PATH_STA := STA
+WIFI_DRIVER_FW_PATH_AP := AP
+WIFI_DRIVER_FW_PATH_P2P := P2P
 
diff --git a/bluetooth/bdroid_buildcfg.h b/bluetooth/bdroid_buildcfg.h
index 8580bee..c689066 100644
--- a/bluetooth/bdroid_buildcfg.h
+++ b/bluetooth/bdroid_buildcfg.h
@@ -1,6 +1,6 @@
 #ifndef _BDROID_BUILDCFG_H
 #define _BDROID_BUILDCFG_H
 
-#define BTM_DEF_LOCAL_NAME   "ApolloLite"
+#define BTM_DEF_LOCAL_NAME   "Vernee Apollo Lite"
 
 #endif
diff --git a/board/audio.mk b/board/audio.mk
deleted file mode 100644
index ea4b445..0000000
--- a/board/audio.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-# Audio
-BOARD_USES_MTK_AUDIO := true
-USE_XML_AUDIO_POLICY_CONF := 1
diff --git a/board/bluetooth.mk b/board/bluetooth.mk
deleted file mode 100644
index d211bd1..0000000
--- a/board/bluetooth.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-# Bluetooth
-MTK_BT_SUPPORT := yes
-BOARD_HAVE_BLUETOOTH := true
-BOARD_HAVE_BLUETOOTH_MTK := true
-BOARD_BLUETOOTH_DOES_NOT_USE_RFKILL := true
-BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR := $(LOCAL_PATH)/bluetooth
diff --git a/board/bootanimation.mk b/board/bootanimation.mk
deleted file mode 100644
index 2562ccf..0000000
--- a/board/bootanimation.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-# Boot animation
-TARGET_BOOTANIMATION_MULTITHREAD_DECODE := true
diff --git a/board/camera.mk b/board/camera.mk
deleted file mode 100644
index 4ca9d3d..0000000
--- a/board/camera.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-# Camera
-USE_CAMERA_STUB := true
diff --git a/board/display.mk b/board/display.mk
deleted file mode 100644
index cd8926b..0000000
--- a/board/display.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-# Display
-NUM_FRAMEBUFFER_SURFACE_BUFFERS := 3
-TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK := true
-TARGET_FORCE_HWC_FOR_VIRTUAL_DISPLAYS := true
-MAX_VIRTUAL_DISPLAY_DIMENSION := 1
-PRESENT_TIME_OFFSET_FROM_VSYNC_NS := 0
-MTK_HWC_SUPPORT := yes
-MTK_HWC_VERSION := 1.4.1
-TARGET_REQUIRES_SYNCHRONOUS_SETSURFACE := true
diff --git a/board/gps.mk b/board/gps.mk
deleted file mode 100644
index 9577e6f..0000000
--- a/board/gps.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-BOARD_MEDIATEK_USES_GPS := true
-BOARD_GPS_LIBRARIES := true
diff --git a/board/hardware.mk b/board/hardware.mk
deleted file mode 100644
index 958fb5d..0000000
--- a/board/hardware.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-# CM hardware
-BOARD_HARDWARE_CLASS := $(LOCAL_PATH)/cmhw
-
-# MTK Hardware
-BOARD_HAS_MTK_HARDWARE := true
-BOARD_USES_MTK_HARDWARE := true
-MTK_HARDWARE := true
-
-# Ashmem
-DISABLE_ASHMEM_TRACKING := true
diff --git a/board/platform.mk b/board/platform.mk
deleted file mode 100644
index 90c044e..0000000
--- a/board/platform.mk
+++ /dev/null
@@ -1,7 +0,0 @@
-# Legacy blobs
-TARGET_NEEDS_PLATFORM_TEXT_RELOCATIONS := true
-
-# Architecture Extensions
-ARCH_ARM_HAVE_TLS_REGISTER := true
-ARCH_ARM_HAVE_NEON := true
-ARCH_ARM_HAVE_VFP := true
diff --git a/board/telephony.mk b/board/telephony.mk
deleted file mode 100644
index 459a1fe..0000000
--- a/board/telephony.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-#ril
-BOARD_RIL_CLASS := ../../../device/vernee/apollo_lite/ril
-BOARD_CONNECTIVITY_MODULE := conn_soc
-
-SIM_COUNT := 2
-PRODUCT_PROPERTY_OVERRIDES += ro.telephony.sim.count=$(SIM_COUNT)
diff --git a/board/wifi.mk b/board/wifi.mk
deleted file mode 100644
index 6a190af..0000000
--- a/board/wifi.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-# Wifi
-WPA_SUPPLICANT_VERSION := VER_0_8_X
-BOARD_HOSTAPD_DRIVER := NL80211
-BOARD_HOSTAPD_PRIVATE_LIB := lib_driver_cmd_mt66xx
-BOARD_WPA_SUPPLICANT_DRIVER := NL80211
-BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_mt66xx
-WIFI_DRIVER_FW_PATH_PARAM := "/dev/wmtWifi"
-WIFI_DRIVER_FW_PATH_STA := STA
-WIFI_DRIVER_FW_PATH_AP := AP
-WIFI_DRIVER_FW_PATH_P2P := P2P
diff --git a/camera/Android.mk b/camera/Android.mk
index 47b9481..ee01360 100644
--- a/camera/Android.mk
+++ b/camera/Android.mk
@@ -1,3 +1,4 @@
+#
 # Copyright (C) 2015 The CyanogenMod Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
@@ -11,6 +12,7 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
+#
 
 LOCAL_PATH := $(call my-dir)
 
@@ -27,3 +29,4 @@ LOCAL_MODULE := libcamera_parameters_ext
 LOCAL_MODULE_TAGS := optional
 
 include $(BUILD_STATIC_LIBRARY)
+
diff --git a/camera/camerasize.xml b/camera/camerasize.xml
index 17301de..7fdd83c 100644
--- a/camera/camerasize.xml
+++ b/camera/camerasize.xml
@@ -1,9 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <camerasize>
-<item name="cameraMain"
-user="0"    
-value="320x240_640x480_1024x768_1280x720_1280x768_1280x960_1600x1200_2048x1536_2560x1440_2560x1920_3264x2448_3328x1872"/>
-<item name="cameraSub"
-user="0"
-value="320x240_640x480_1024x768_1280x720_1280x768_1280x960_1600x1200_2048x1536_2560x1440_2560x1920" />
+
+  <item name="cameraMain"
+        user="0"    
+        value="320x240_640x480_1024x768_1280x720_1280x768_1280x960_1600x1200_2048x1536_2560x1440_2560x1920_3264x2448_3328x1872"/>
+
+  <item name="cameraSub"
+        user="0"
+        value="320x240_640x480_1024x768_1280x720_1280x768_1280x960_1600x1200_2048x1536_2560x1440_2560x1920" />
+
 </camerasize>
diff --git a/device.mk b/device.mk
index db6b50f..a2826ba 100644
--- a/device.mk
+++ b/device.mk
@@ -1,27 +1,126 @@
 LOCAL_PATH := device/vernee/apollo_lite
 
-DEVICE_PACKAGE_OVERLAYS += $(LOCAL_PATH)/overlay
 
-# Enable Minikin text layout engine (will be the default soon)
-USE_MINIKIN := true
+# Device Configuration for Vernee Apollo Lite
 
-# Configure jemalloc for low memory
-MALLOC_SVELTE := true
 
-# Screen density
-PRODUCT_AAPT_CONFIG := normal
-PRODUCT_AAPT_PREF_CONFIG := xxhdpi
-PRODUCT_AAPT_PREBUILT_DPI := xxhdpi xhdpi 280dpi hdpi tvdpi mdpi ldpi
+# Audio
+PRODUCT_PACKAGES += \
+    audio_policy.default \
+    audio.r_submix.default \
+    audio.a2dp.default \
+    audio.usb.default
 
-# Recovery allowed devices
-TARGET_OTA_ASSERT_DEVICE := lite,apollo_lite,k15tb_a
+PRODUCT_COPY_FILES += \
+    frameworks/av/services/audiopolicy/config/audio_policy_volumes.xml:/system/etc/audio_policy_volumes.xml \
+    frameworks/av/services/audiopolicy/config/default_volume_tables.xml:/system/etc/default_volume_tables.xml \
+    frameworks/av/services/audiopolicy/config/r_submix_audio_policy_configuration.xml:/system/etc/r_submix_audio_policy_configuration.xml \
+    frameworks/av/services/audiopolicy/config/usb_audio_policy_configuration.xml:/system/etc/usb_audio_policy_configuration.xml
 
-# Audio
 PRODUCT_COPY_FILES += \
     $(LOCAL_PATH)/configs/audio/audio_device.xml:system/etc/audio_device.xml \
     $(LOCAL_PATH)/configs/audio/audio_policy_configuration.xml:system/etc/audio_policy_configuration.xml \
     $(LOCAL_PATH)/configs/audio/a2dp_audio_policy_configuration.xml:/system/etc/a2dp_audio_policy_configuration.xml
 
+# Browser
+PRODUCT_PACKAGES += \
+    Gello
+
+# Camera
+PRODUCT_COPY_FILES += \
+    $(LOCAL_PATH)/camera/camerasize.xml:system/etc/camerasize.xml \
+    $(LOCAL_PATH)/configs/permissions/android.hardware.camera.xml:system/etc/permissions/android.hardware.camera.xml \
+    frameworks/native/data/etc/android.hardware.camera.flash-autofocus.xml:system/etc/permissions/android.hardware.camera.flash-autofocus.xml \
+    frameworks/native/data/etc/android.hardware.camera.front.xml:system/etc/permissions/android.hardware.camera.front.xml \
+    frameworks/native/data/etc/android.hardware.camera.raw.xml:system/etc/permissions/android.hardware.camera.raw.xml
+
+PRODUCT_PACKAGES += \
+    Snap
+
+# Charger
+PRODUCT_PACKAGES += \
+    charger
+
+# Codecs
+PRODUCT_COPY_FILES += \
+    frameworks/av/media/libstagefright/data/media_codecs_google_audio.xml:system/etc/media_codecs_google_audio.xml \
+    frameworks/av/media/libstagefright/data/media_codecs_google_telephony.xml:system/etc/media_codecs_google_telephony.xml \
+    frameworks/av/media/libstagefright/data/media_codecs_google_video_le.xml:system/etc/media_codecs_google_video_le.xml
+
+# Configurations
+PRODUCT_COPY_FILES += \
+    $(LOCAL_PATH)/configs/apns-conf.xml:system/etc/apns-conf.xml \
+    $(LOCAL_PATH)/configs/ecc_list.xml:system/etc/ecc_list.xml \
+    $(LOCAL_PATH)/configs/spn-conf.xml:system/etc/spn-conf.xml
+
+PRODUCT_PACKAGES += \
+    messaging \
+    Stk
+
+# Dalvik
+PRODUCT_TAGS += dalvik.gc.type-precise
+
+# Default.prop
+PRODUCT_DEFAULT_PROPERTY_OVERRIDES += \
+    camera.disable_zsl_mode=1 \
+    persist.service.acm.enable=0 \
+    persist.service.acm.enable=0 \
+    persist.sys.dun.override=0 \
+    ro.adb.secure=0 \
+    ro.allow.mock.location=1 \
+    ro.debuggable=1 \
+    ro.mount.fs=EXT4 \
+    ro.oem_unlock_supported=1 \
+    ro.secure=0
+
+# Display
+PRODUCT_PACKAGES += \
+    libion
+
+# Filesystem Management Tools
+PRODUCT_PACKAGES += \
+    e2fsck \
+    fsck.f2fs \
+    mkfs.f2fs \
+    make_ext4fs
+
+PRODUCT_PACKAGES += \
+    mount.exfat \
+    fsck.exfat \
+    mkfs.exfat
+
+PRODUCT_PACKAGES += \
+    fsck.ntfs \
+    mkfs.ntfs \
+    mount.ntfs
+
+# Fingerprint
+PRODUCT_COPY_FILES += \
+    frameworks/native/data/etc/android.hardware.fingerprint.xml:system/etc/permissions/android.hardware.fingerprint.xml
+
+PRODUCT_PACKAGES += \
+    fingerprintd
+
+# FMRadio
+MTK_FM_SUPPORT := true
+
+PRODUCT_PACKAGES += \
+    libfmjni \
+    FMRadio
+
+# GPS
+PRODUCT_COPY_FILES += \
+    $(LOCAL_PATH)/configs/agps_profiles_conf2.xml:system/etc/agps_profiles_conf2.xml \
+    frameworks/native/data/etc/android.hardware.location.gps.xml:system/etc/permissions/android.hardware.location.gps.xml
+
+# Hardware-Specific Permissions
+PRODUCT_COPY_FILES += \
+    frameworks/native/data/etc/android.hardware.vulkan.level-0.xml:system/etc/permissions/android.hardware.vulkan.level.xml \
+    frameworks/native/data/etc/android.hardware.vulkan.version-1_0_3.xml:system/etc/permissions/android.hardware.vulkan.version.xml
+
+# Malloc Svelte
+MALLOC_SVELTE := true
+
 # Media
 PRODUCT_COPY_FILES += \
 	$(LOCAL_PATH)/configs/media_codecs.xml:system/etc/media_codecs.xml \
@@ -29,6 +128,42 @@ PRODUCT_COPY_FILES += \
 	$(LOCAL_PATH)/configs/media_codecs_performance.xml:system/etc/media_codecs_performance.xml \
 	$(LOCAL_PATH)/configs/media_profiles.xml:system/etc/media_profiles.xml
 
+# Mediatek
+PRODUCT_PACKAGES += \
+    libstlport \
+    libmtk_symbols \
+    libxlog
+
+# Minikin
+USE_MINIKIN := true
+
+# Overlay
+DEVICE_PACKAGE_OVERLAYS += $(LOCAL_PATH)/overlay
+
+# Permissions
+PRODUCT_COPY_FILES += \
+    frameworks/native/data/etc/android.hardware.bluetooth.xml:system/etc/permissions/android.hardware.bluetooth.xml \
+    frameworks/native/data/etc/android.hardware.bluetooth_le.xml:system/etc/permissions/android.hardware.bluetooth_le.xml \
+    frameworks/native/data/etc/android.hardware.telephony.cdma.xml:system/etc/permissions/android.hardware.telephony.cdma.xml \
+    frameworks/native/data/etc/android.hardware.telephony.gsm.xml:system/etc/permissions/android.hardware.telephony.gsm.xml \
+    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.distinct.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.distinct.xml \
+    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.jazzhand.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.jazzhand.xml \
+    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.xml \
+    frameworks/native/data/etc/android.hardware.touchscreen.xml:system/etc/permissions/android.hardware.touchscreen.xml \
+    frameworks/native/data/etc/android.hardware.usb.accessory.xml:system/etc/permissions/android.hardware.usb.accessory.xml \
+    frameworks/native/data/etc/android.hardware.usb.host.xml:system/etc/permissions/android.hardware.usb.host.xml \
+    frameworks/native/data/etc/handheld_core_hardware.xml:system/etc/permissions/handheld_core_hardware.xml
+
+# Power
+PRODUCT_PACKAGES += \
+    power.default \
+    power.mt6797
+
+# Radio Dependencies
+PRODUCT_PACKAGES += \
+    muxreport \
+    terservice
+
 # Ramdisk
 PRODUCT_COPY_FILES += \
     $(LOCAL_PATH)/rootdir/factory_init.project.rc:root/factory_init.project.rc \
@@ -42,18 +177,79 @@ PRODUCT_COPY_FILES += \
     $(LOCAL_PATH)/rootdir/meta_init.rc:root/meta_init.rc \
     $(LOCAL_PATH)/rootdir/ueventd.mt6797.rc:root/ueventd.mt6797.rc
 
+# Recovery-Allowed Devices
+TARGET_OTA_ASSERT_DEVICE := lite,apollo_lite,k15tb_a
+
+# RIL
+PRODUCT_PROPERTY_OVERRIDES += \
+    ro.kernel.android.checkjni=0 \
+    ro.telephony.ril_class=MediaTekRIL \
+    ro.telephony.ril.config=fakeiccid \
+    ro.com.android.mobiledata=false
+
+# Screen Density
+PRODUCT_AAPT_CONFIG := normal
+PRODUCT_AAPT_PREF_CONFIG := xxhdpi
+PRODUCT_AAPT_PREBUILT_DPI := xxhdpi xhdpi 280dpi hdpi tvdpi mdpi ldpi
+
+# Sensors
+PRODUCT_COPY_FILES += \
+    frameworks/native/data/etc/android.hardware.sensor.accelerometer.xml:system/etc/permissions/android.hardware.sensor.accelerometer.xml \
+    frameworks/native/data/etc/android.hardware.sensor.compass.xml:system/etc/permissions/android.hardware.compass.xml \
+    frameworks/native/data/etc/android.hardware.sensor.light.xml:system/etc/permissions/android.hardware.sensor.light.xml \
+    frameworks/native/data/etc/android.hardware.sensor.gyroscope.xml:system/etc/permissions/android.hardware.sensor.gyroscope.xml \
+    frameworks/native/data/etc/android.hardware.sensor.proximity.xml:system/etc/permissions/android.hardware.sensor.proximity.xml \
+    frameworks/native/data/etc/android.hardware.sensor.stepcounter.xml:system/etc/permissions/android.hardware.sensor.stepcounter.xml \
+    frameworks/native/data/etc/android.hardware.sensor.stepdetector.xml:system/etc/permissions/android.hardware.sensor.stepdetector.xml
+
+PRODUCT_PACKAGES += \
+    libem_sensor_jni
+
+# Tethering
+PRODUCT_PROPERTY_OVERRIDES += \
+    net.tethering.noprovisioning=true
+
+# Thermal
+PRODUCT_COPY_FILES += \
+    $(LOCAL_PATH)/configs/thermal/.ht120.mtc:system/etc/.tp/.ht120.mtc \
+    $(LOCAL_PATH)/configs/thermal/thermal.conf:system/etc/.tp/thermal.conf \
+    $(LOCAL_PATH)/configs/thermal/thermal.off.conf:system/etc/.tp/thermal.off.conf \
+    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_00 \
+    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_01 \
+    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_02 \
+    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_03
+
 # TWRP
 PRODUCT_COPY_FILES += \
     $(LOCAL_PATH)/recovery/etc/twrp.fstab:recovery/root/etc/twrp.fstab
 
-# Device product elements
-include $(LOCAL_PATH)/product/*.mk
+# USB
+PRODUCT_PACKAGES += \
+    librs_jni \
+    com.android.future.usb.accessory
 
-# Dalvik heap configurations
-$(call inherit-product-if-exists, frameworks/native/build/phone-xxhdpi-4096-dalvik-heap.mk)
+# Wallpaper Picker
+PRODUCT_PACKAGES += \
+    WallpaperPicker
 
-# Call hwui memory config
-$(call inherit-product-if-exists, frameworks/native/build/phone-xxhdpi-4096-hwui-memory.mk)
+# WIFI
+PRODUCT_COPY_FILES += \
+    frameworks/native/data/etc/android.hardware.wifi.xml:system/etc/permissions/android.hardware.wifi.xml \
+    frameworks/native/data/etc/android.hardware.wifi.direct.xml:system/etc/permissions/android.hardware.wifi.direct.xml
+
+PRODUCT_PACKAGES += \
+    lib_driver_cmd_mt66xx \
+    libwpa_client \
+    hostapd \
+    wpa_supplicant
+
+PRODUCT_COPY_FILES += \
+    $(LOCAL_PATH)/configs/wifi/wpa_supplicant.conf:system/etc/wifi/wpa_supplicant.conf \
+    $(LOCAL_PATH)/configs/wifi/wpa_supplicant_overlay.conf:system/etc/wifi/wpa_supplicant_overlay.conf \
+    $(LOCAL_PATH)/configs/wifi/p2p_supplicant_overlay.conf:system/etc/wifi/p2p_supplicant_overlay.conf
 
-# Vendor
+# Configurations for Dalvik Heap, HWUI Memory and Vendor Blobs
+$(call inherit-product-if-exists, frameworks/native/build/phone-xxhdpi-4096-dalvik-heap.mk)
+$(call inherit-product-if-exists, frameworks/native/build/phone-xxhdpi-4096-hwui-memory.mk)
 $(call inherit-product, vendor/vernee/apollo_lite/apollo_lite-vendor.mk)
+
diff --git a/gralloc_extra/Android.mk b/gralloc_extra/Android.mk
deleted file mode 100755
index ba84ca9..0000000
--- a/gralloc_extra/Android.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-ifneq ($(filter apollo_lite, $(TARGET_DEVICE)),)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-	GraphicBufferExtra.cpp \
-	GraphicBufferExtra_hal.cpp
-
-LOCAL_C_INCLUDES := \
-	$(LOCAL_PATH)/include
-
-LOCAL_SHARED_LIBRARIES := \
-	libhardware \
-	libcutils \
-	libutils
-
-LOCAL_MODULE := libgralloc_extra
-
-include $(BUILD_SHARED_LIBRARY)
-endif
diff --git a/gralloc_extra/GraphicBufferExtra.cpp b/gralloc_extra/GraphicBufferExtra.cpp
deleted file mode 100755
index d1cbffc..0000000
--- a/gralloc_extra/GraphicBufferExtra.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-#define LOG_TAG "GraphicBufferExtra"
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-#include <cutils/log.h>
-#include <ui/GraphicBufferExtra.h>
-#include <graphics_mtk_defs.h>
-
-namespace android {
-// ---------------------------------------------------------------------------
-
-ANDROID_SINGLETON_STATIC_INSTANCE( GraphicBufferExtra )
-
-static GraphicBufferExtra * s_singleton_obj = NULL;
-
-GraphicBufferExtra::GraphicBufferExtra()
-    : mExtraDev(0)
-{
-    hw_module_t const* module;
-    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
-
-    ALOGE_IF(err, "FATAL: can't find the %s module", GRALLOC_HARDWARE_MODULE_ID);
-    if (err == 0)
-    {
-        gralloc_extra_open(module, &mExtraDev);
-    }
-
-    s_singleton_obj = this;
-}
-
-// dlclose
-static void __attribute__((destructor)) gralloc_extra_dlclose(void)
-{
-    if (s_singleton_obj)
-    {
-        delete s_singleton_obj;
-        s_singleton_obj = NULL;
-    }
-}
-
-GraphicBufferExtra::~GraphicBufferExtra()
-{
-    if (mExtraDev)
-    {
-        gralloc_extra_close(mExtraDev);
-    }
-    s_singleton_obj = NULL;
-}
-
-// ---------------------------------------------------------------------------
-}; // namespace android
diff --git a/gralloc_extra/GraphicBufferExtra_hal.cpp b/gralloc_extra/GraphicBufferExtra_hal.cpp
deleted file mode 100755
index eba0ab3..0000000
--- a/gralloc_extra/GraphicBufferExtra_hal.cpp
+++ /dev/null
@@ -1,224 +0,0 @@
-
-#define LOG_TAG "GraphicBufferExtra_hal"
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#include <stdint.h>
-#include <errno.h>
-
-#include <utils/Errors.h>
-#include <utils/Log.h>
-#include <utils/Trace.h>
-
-#include <system/graphics.h>
-#include <graphics_mtk_defs.h>
-
-#include <hardware/gralloc.h>
-#include <hardware/gralloc_extra.h>
-
-#include <ui/GraphicBufferExtra.h>
-
-/* ----  IMPLEMENTATION macro  ---- */
-
-#define GRALLOC_EXTRA_PROTOTYPE_(...)  ( __VA_ARGS__ )
-#define GRALLOC_EXTRA_ARGS_(...)       ( __VA_ARGS__ )
-#define GRALLOC_EXTRA_ARGS_2(...)      ( mExtraDev, __VA_ARGS__ )
-#define GRALLOC_EXTRA_CHECK_FAIL_RETURN_(API, ERR)                      \
-do {                                                                    \
-    if (!mExtraDev)                                                     \
-    {                                                                   \
-        ALOGD("gralloc extra device is not supported");                 \
-        return ERR;                                                     \
-    }                                                                   \
-                                                                        \
-    if (!mExtraDev->API)                                                \
-    {                                                                   \
-        ALOGW("gralloc extra device " #API "(...) is not supported");   \
-        return ERR;                                                     \
-    }                                                                   \
-} while(0)
-
-
-#define GRALLOC_EXTRA_IMPLEMENTATION_(RET, ERR, API, PROTOTYPE, ARGS)   \
-RET android::GraphicBufferExtra:: API PROTOTYPE                         \
-{                                                                       \
-    ATRACE_CALL();                                                      \
-    RET err;                                                            \
-                                                                        \
-    GRALLOC_EXTRA_CHECK_FAIL_RETURN_(API, ERR);                         \
-                                                                        \
-    err = mExtraDev-> API GRALLOC_EXTRA_ARGS_2 ARGS ;                   \
-                                                                        \
-    if (err < 0) ALOGW(#API"(...) failed %d", err);                     \
-                                                                        \
-    return err;                                                         \
-}                                                                       \
-extern "C" RET gralloc_extra_##API PROTOTYPE                            \
-{                                                                       \
-    return android::GraphicBufferExtra::get(). API ARGS;                \
-}
-
-/* ----  IMPLEMENTATION start  ---- */
-
-GRALLOC_EXTRA_IMPLEMENTATION_(int, -1, getIonFd, 
-    GRALLOC_EXTRA_PROTOTYPE_(buffer_handle_t handle, int *idx, int *num), 
-    GRALLOC_EXTRA_ARGS_(handle, idx, num)
-)
-
-GRALLOC_EXTRA_IMPLEMENTATION_(int, -1, getSecureBuffer, 
-    GRALLOC_EXTRA_PROTOTYPE_(buffer_handle_t handle, int *type, int *hBuffer), 
-    GRALLOC_EXTRA_ARGS_(handle, type, hBuffer)
-)
-
-GRALLOC_EXTRA_IMPLEMENTATION_(int, -1, getBufInfo, 
-    GRALLOC_EXTRA_PROTOTYPE_(buffer_handle_t handle, gralloc_buffer_info_t* bufInfo), 
-    GRALLOC_EXTRA_ARGS_(handle, bufInfo)
-)
-
-GRALLOC_EXTRA_IMPLEMENTATION_(int, -1, setBufParameter, 
-    GRALLOC_EXTRA_PROTOTYPE_(buffer_handle_t handle, int mask, int value), 
-    GRALLOC_EXTRA_ARGS_(handle, mask, value)
-)
-	
-GRALLOC_EXTRA_IMPLEMENTATION_(int, -1, getMVA, 
-    GRALLOC_EXTRA_PROTOTYPE_(buffer_handle_t handle, int *mvaddr), 
-    GRALLOC_EXTRA_ARGS_(handle, mvaddr)
-)
-
-GRALLOC_EXTRA_IMPLEMENTATION_(int, -1, setBufInfo, 
-    GRALLOC_EXTRA_PROTOTYPE_(buffer_handle_t handle, const char * str), 
-    GRALLOC_EXTRA_ARGS_(handle, str)
-)
-
-/* ----  IMPLEMENTATION start end  ---- */
-
-#undef GRALLOC_EXTRA_CHECK_FAIL_RETURN_
-#undef GRALLOC_EXTRA_IMPLEMENTATION_
-#undef GRALLOC_EXTRA_PROTOTYPE_
-#undef GRALLOC_EXTRA_ARGS_
-#undef GRALLOC_EXTRA_ARGS_2
-
-int android::GraphicBufferExtra::query(
-        buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_QUERY attribute, void * out_pointer) 
-{ 
-    ATRACE_CALL(); 
-    int err; 
-    if (!mExtraDev || !mExtraDev->query)
-    {
-        ALOGW("gralloc extra device query(...) is not supported");
-        return -GRALLOC_EXTRA_NOT_SUPPORTED;
-    }
-    err = mExtraDev->query(mExtraDev, handle, attribute, out_pointer);
-    if (err < 0) 
-        ALOGW("query(0x%x) failed %d", attribute, err);
-    return err; 
-} 
-
-int android::GraphicBufferExtra::perform(
-        buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_PERFORM attribute, void * in_pointer) 
-{ 
-    ATRACE_CALL(); 
-    int err; 
-    if (!mExtraDev || !mExtraDev->perform)
-    {
-        ALOGW("gralloc extra device perform(...) is not supported");
-        return -GRALLOC_EXTRA_NOT_SUPPORTED;
-    }
-    err = mExtraDev->perform(mExtraDev, handle, attribute, in_pointer); 
-    if (err < 0)
-        ALOGW("perform(0x%x) failed %d", attribute, err); 
-    return err; 
-} 
-
-
-#if 0
-int android::GraphicBufferExtra::free_sec(
-        buffer_handle_t handle)
-{
-    ATRACE_CALL();
-    int err;
-    if (!mExtraDev || !mExtraDev->perform)
-    {
-        ALOGW("gralloc extra device perform(...) is not supported");
-        return -GRALLOC_EXTRA_NOT_SUPPORTED;
-    }
-    err = mExtraDev->free_sec(mExtraDev, handle);
-    if (err < 0)
-        ALOGW("free_sec failed %d", err);
-    return err;
-}
-#endif
-
-
-extern "C" int gralloc_extra_query(
-        buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_QUERY attribute, void * out_pointer) 
-{ 
-    return android::GraphicBufferExtra::get().query(handle, attribute, out_pointer); 
-}
-
-extern "C" int gralloc_extra_perform(
-        buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_PERFORM attribute, void * in_pointer) 
-{ 
-    return android::GraphicBufferExtra::get().perform(handle, attribute, in_pointer); 
-}
-
-#if 0
-extern "C" int gralloc_extra_free_sec(buffer_handle_t handle )
-{
-    return android::GraphicBufferExtra::get().free_sec(handle);
-}
-#endif
-
-
-static int __gralloc_extra_sf_set_int(int *data, int32_t mask, int32_t value)
-{
-    int32_t old_status;
-    int32_t new_status;
-
-    old_status = *data;
-    new_status = ( old_status & (~mask) );
-    new_status |= ( value & mask );
-
-    /* Force modify the const member */
-    *data = new_status;
-
-    return GRALLOC_EXTRA_OK;
-}
-
-extern "C" int gralloc_extra_sf_set_status(gralloc_extra_ion_sf_info_t *sf_info, int32_t mask, int32_t value)
-{
-    return __gralloc_extra_sf_set_int(&sf_info->status, mask, value);
-}
-
-extern "C" int gralloc_extra_sf_set_status2(gralloc_extra_ion_sf_info_t *sf_info, int32_t mask, int32_t value)
-{
-    return __gralloc_extra_sf_set_int(&sf_info->status2, mask, value);
-}
-
-/* init the sf_info */
-extern "C" int gralloc_extra_sf_init(buffer_handle_t handle, gralloc_extra_ion_sf_info_t * sf_info)
-{
-    int32_t mask = 0;
-    int32_t value = 0;
-    int format;
-
-    memset(sf_info, 0, sizeof(gralloc_extra_ion_sf_info_t));
-
-    if (GRALLOC_EXTRA_OK == gralloc_extra_query(handle, GRALLOC_EXTRA_GET_FORMAT, &format))
-    {
-        if (format == HAL_PIXEL_FORMAT_YV12 ||
-            format == HAL_PIXEL_FORMAT_I420 ||
-            format == HAL_PIXEL_FORMAT_YUV_PRIVATE ||
-            format == HAL_PIXEL_FORMAT_NV12_BLK ||
-            format == HAL_PIXEL_FORMAT_NV12_BLK_FCM ||
-            format == HAL_PIXEL_FORMAT_YUYV ||
-            0 )
-        {
-            mask |= GRALLOC_EXTRA_MASK_YUV_COLORSPACE;
-            value |= GRALLOC_EXTRA_BIT_YUV_BT601_NARROW;
-        }
-    }
-
-    gralloc_extra_sf_set_status(sf_info, mask, value);
-    return 0;
-}
-
diff --git a/gralloc_extra/NOTICE b/gralloc_extra/NOTICE
deleted file mode 100755
index 268fe09..0000000
--- a/gralloc_extra/NOTICE
+++ /dev/null
@@ -1,22 +0,0 @@
- *      (C) COPYRIGHT 2014 ARM Limited, ALL RIGHTS RESERVED:
-
-
-
-/*
-* Copyright (C) 2011-2014 MediaTek Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-
- 
\ No newline at end of file
diff --git a/gralloc_extra/README b/gralloc_extra/README
deleted file mode 100755
index 4500bab..0000000
--- a/gralloc_extra/README
+++ /dev/null
@@ -1,19 +0,0 @@
-A gralloc extra HAL to retrive buffer detail information.
-
-WHAT IT DOES?
-=============
-libgralloc_extra.so provide a convenience API for retriving the buffer_t
-information, such as width, height, real format, raw buffer handle and more
-extra share space for MTK's HWC, Video, and Camera.
-
-HOW IT WAS BUILT?
-==================
-It needs the following library from AOSP:
-1.  libhardware
-2.  libcutils
-3.  libutils
-
-HOW TO USE IT?
-==============
-See the usage of gralloc_extra_* at ./tests/
-gralloc_test.cpp
\ No newline at end of file
diff --git a/gralloc_extra/include/gralloc_mtk_defs.h b/gralloc_extra/include/gralloc_mtk_defs.h
deleted file mode 100755
index 85edf8b..0000000
--- a/gralloc_extra/include/gralloc_mtk_defs.h
+++ /dev/null
@@ -1,95 +0,0 @@
-#ifndef __GRALLOC_MTK_DEFS_H__
-#define __GRALLOC_MTK_DEFS_H__
-
-#include <stdint.h>
-#include <hardware/gralloc.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-   [Important]
-   Define the MTK specific enumeration values for gralloc usage in order to avoid "polute" AOSP file
-   (hardware/libhardware/include/hardware/gralloc.h)
-   The enumeration value definition must not be conflict with the gralloc.h in original AOSP file
-*/
-enum {
-
-#if 0
-    /* buffer is never read in software */
-    GRALLOC_USAGE_SW_READ_NEVER         = 0x00000000,
-    /* buffer is rarely read in software */
-    GRALLOC_USAGE_SW_READ_RARELY        = 0x00000002,
-    /* buffer is often read in software */
-    GRALLOC_USAGE_SW_READ_OFTEN         = 0x00000003,
-    /* mask for the software read values */
-    GRALLOC_USAGE_SW_READ_MASK          = 0x0000000F,
-
-    /* buffer is never written in software */
-    GRALLOC_USAGE_SW_WRITE_NEVER        = 0x00000000,
-    /* buffer is rarely written in software */
-    GRALLOC_USAGE_SW_WRITE_RARELY       = 0x00000020,
-    /* buffer is often written in software */
-    GRALLOC_USAGE_SW_WRITE_OFTEN        = 0x00000030,
-    /* mask for the software write values */
-    GRALLOC_USAGE_SW_WRITE_MASK         = 0x000000F0,
-
-    /* buffer will be used as an OpenGL ES texture */
-    GRALLOC_USAGE_HW_TEXTURE            = 0x00000100,
-    /* buffer will be used as an OpenGL ES render target */
-    GRALLOC_USAGE_HW_RENDER             = 0x00000200,
-    /* buffer will be used by the 2D hardware blitter */
-    GRALLOC_USAGE_HW_2D                 = 0x00000400,
-    /* buffer will be used by the HWComposer HAL module */
-    GRALLOC_USAGE_HW_COMPOSER           = 0x00000800,
-    /* buffer will be used with the framebuffer device */
-    GRALLOC_USAGE_HW_FB                 = 0x00001000,
-    /* buffer will be used with the HW video encoder */
-    GRALLOC_USAGE_HW_VIDEO_ENCODER      = 0x00010000,
-    /* buffer will be written by the HW camera pipeline */
-    GRALLOC_USAGE_HW_CAMERA_WRITE       = 0x00020000,
-    /* buffer will be read by the HW camera pipeline */
-    GRALLOC_USAGE_HW_CAMERA_READ        = 0x00040000,
-    /* buffer will be used as part of zero-shutter-lag queue */
-    GRALLOC_USAGE_HW_CAMERA_ZSL         = 0x00060000,
-    /* mask for the camera access values */
-    GRALLOC_USAGE_HW_CAMERA_MASK        = 0x00060000,
-    /* mask for the software usage bit-mask */
-    GRALLOC_USAGE_HW_MASK               = 0x00071F00,
-
-    /* buffer will be used as a RenderScript Allocation */
-    GRALLOC_USAGE_RENDERSCRIPT          = 0x00100000,
-
-    /* buffer should be displayed full-screen on an external display when
-     * possible
-     */
-    GRALLOC_USAGE_EXTERNAL_DISP         = 0x00002000,
-
-    /* Must have a hardware-protected path to external display sink for
-     * this buffer.  If a hardware-protected path is not available, then
-     * either don't composite only this buffer (preferred) to the
-     * external sink, or (less desirable) do not route the entire
-     * composition to the external sink.
-     */
-    GRALLOC_USAGE_PROTECTED             = 0x00004000,
-
-    /* implementation-specific private usage flags */
-    GRALLOC_USAGE_PRIVATE_0             = 0x10000000,
-    GRALLOC_USAGE_PRIVATE_1             = 0x20000000,
-    GRALLOC_USAGE_PRIVATE_2             = 0x40000000,
-    GRALLOC_USAGE_PRIVATE_3             = 0x80000000,
-    GRALLOC_USAGE_PRIVATE_MASK          = 0xF0000000,
-#endif /// #if 0
-
-    /// the following define the extended gralloc enumeration value of
-    GRALLOC_USAGE_NULL_BUFFER           = GRALLOC_USAGE_PRIVATE_3,
-    GRALLOC_USAGE_SECURE                = 0x01000000,
-    GRALLOC_USAGE_CAMERA_ORIENTATION   = 0x02000000,
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __GRALLOC_MTK_DEFS_H__ */
diff --git a/gralloc_extra/include/graphics_mtk_defs.h b/gralloc_extra/include/graphics_mtk_defs.h
deleted file mode 100755
index 6374984..0000000
--- a/gralloc_extra/include/graphics_mtk_defs.h
+++ /dev/null
@@ -1,69 +0,0 @@
-#ifndef __GRAPHICS_MTK_DEFS_H__
-#define __GRAPHICS_MTK_DEFS_H__
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-   [Important]
-   Define the OMX MTK specific enum values in order to avoid "polute" AOSP files(system/core/graphics.h)
-   The format enum value definition must be align to the enum value in the following file
-   frameworks\av\media\libstagefright\include\omx_core\OMX_IVCommon.h
-*/
-#define OMX_COLOR_FormatVendorMTKYUV     0x7F000001
-#define OMX_COLOR_FormatVendorMTKYUV_FCM 0x7F000002
-#define OMX_COLOR_FormatVendorMTKYUV_10BIT_H 0x7F000004
-#define OMX_COLOR_FormatVendorMTKYUV_10BIT_V 0x7F000005
-#define OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_H 0x7F000006
-#define OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_V 0x7F000007
-
-/**
- * MTK pixel format definitions
- */
-enum {
-#ifndef MTK_BUILD_IMG_DDK
-    HAL_PIXEL_FORMAT_BGRX_8888      = 0xFFFF0002,
-#endif
-
-    HAL_PIXEL_FORMAT_I420           = 0x32315659 + 0x10,                 /// MTK I420
-    HAL_PIXEL_FORMAT_YUV_PRIVATE    = 0x32315659 + 0x20,                 /// I420 or NV12_BLK or NV12_BLK_FCM
-    HAL_PIXEL_FORMAT_YUV_PRIVATE_10BIT    = 0x32315659 + 0x30,           /// I420 or NV12_BLK or NV12_BLK_FCM - 10bit
-
-    HAL_PIXEL_FORMAT_NV12_BLK       = OMX_COLOR_FormatVendorMTKYUV,      /// MTK NV12 block progressive mode
-    HAL_PIXEL_FORMAT_NV12_BLK_FCM   = OMX_COLOR_FormatVendorMTKYUV_FCM,  /// MTK NV12 block field mode
-    HAL_PIXEL_FORMAT_NV12_BLK_10BIT_H = OMX_COLOR_FormatVendorMTKYUV_10BIT_H,  /// MTK NV12 10 bit horizontal mode
-    HAL_PIXEL_FORMAT_NV12_BLK_10BIT_V = OMX_COLOR_FormatVendorMTKYUV_10BIT_V,  /// MTK NV12 10 bit vertical mode
-    HAL_PIXEL_FORMAT_UFO_10BIT_H    = OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_H,  /// MTK NV12 10 bit UFO horizontal mode
-    HAL_PIXEL_FORMAT_UFO_10BIT_V    = OMX_COLOR_FormatVendorMTKYUV_UFO_10BIT_V,  /// MTK NV12 10 bit UFO vertical mode
-
-/**
- * IMG Driver use 0x1X0-0x1X6 as they "vendor formats"
- */
-    HAL_PIXEL_FORMAT_IMG0           = 0x00000100,
-    HAL_PIXEL_FORMAT_IMG1_BGRX_8888 = 0x00000101,
-    HAL_PIXEL_FORMAT_IMG2           = 0x00000102,
-    HAL_PIXEL_FORMAT_IMG3           = 0x00000103,
-    HAL_PIXEL_FORMAT_IMG4           = 0x00000105,
-    HAL_PIXEL_FORMAT_IMG5           = 0x00000106,
-
-    HAL_PIXEL_FORMAT_YUYV           = 0x0000010c,                        /// for HWC output (bpp=2)
-    HAL_PIXEL_FORMAT_I420_DI        = 0x0000010d,                        /// MTK I420 for deinterlace
-    HAL_PIXEL_FORMAT_YV12_DI        = 0x0000010e,                        /// MTK YV12 for deinterlace
-    HAL_PIXEL_FORMAT_UFO            = 0x0000010f,                        /// MTK UFO
-    HAL_PIXEL_FORMAT_NV12           = 0x00000110,                        /// NV12
-
-/**
- * Sapphire Driver use 0x120-0x121 as their "vendor formats"
- */
-    HAL_PIXEL_FORMAT_SPH0           = 0x00000120,
-    HAL_PIXEL_FORMAT_SPH1           = 0x00000121,
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __GRAPHICS_MTK_DEFS_H__ */
diff --git a/gralloc_extra/include/hardware/gralloc_extra.h b/gralloc_extra/include/hardware/gralloc_extra.h
deleted file mode 100755
index 653ba0f..0000000
--- a/gralloc_extra/include/hardware/gralloc_extra.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#ifndef MTK_GRALLOC_EXTRA_DEVICE_H
-#define MTK_GRALLOC_EXTRA_DEVICE_H
-
-#include <system/window.h>
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include <stdint.h>
-#include <sys/cdefs.h>
-#include <sys/types.h>
-
-#include <ui/gralloc_extra.h>
-
-__BEGIN_DECLS
-
-#define GRALLOC_HARDWARE_EXTRA "extra"
-
-typedef struct extra_device_t {
-    struct hw_device_t common;
-
-    /** Deprecated methods and struct. START */
-    int (*getIonFd)(struct extra_device_t* dev, buffer_handle_t handle, int *idx, int *num);
-    int (*getBufInfo)(struct extra_device_t *dev, buffer_handle_t handle, gralloc_buffer_info_t* bufInfo);
-    int (*getSecureBuffer)(struct extra_device_t* dev, buffer_handle_t handle, int *type, int *hBuffer);
-    int (*setBufParameter)(struct extra_device_t* dev, buffer_handle_t handle, int mask, int value);
-    int (*getMVA)(struct extra_device_t* dev, buffer_handle_t handle, int32_t *mvaddr);
-    int (*setBufInfo)(struct extra_device_t* dev, buffer_handle_t handle, const char* str);
-    /** Deprecated methods and struct. END */
-
-    int (*query)(struct extra_device_t* dev,
-        buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_QUERY attribute, void * out_pointer);
-
-    int (*perform)(struct extra_device_t* dev,
-        buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_PERFORM attribute, void * in_pointer);
-    #if 0
-    int (*free_sec)(struct extra_device_t* dev, buffer_handle_t handle);
-    #endif
-	
-    void* reserved_proc[2];
-} extra_device_t;
-
-
-/** convenience API for opening and closing a supported device */
-
-static inline int gralloc_extra_open(const struct hw_module_t* module,
-        struct extra_device_t** device) {
-    return module->methods->open(module,
-            GRALLOC_HARDWARE_EXTRA, (struct hw_device_t**)device);
-}
-
-static inline int gralloc_extra_close(struct extra_device_t* device) {
-    return device->common.close(&device->common);
-}
-
-/* common function to init sf_info */
-int gralloc_extra_sf_init(buffer_handle_t handle, gralloc_extra_ion_sf_info_t * sf_info);
-
-__END_DECLS
-
-#endif // MTK_GRALLOC_EXTRA_DEVICE_H
diff --git a/gralloc_extra/include/ui/GraphicBufferExtra.h b/gralloc_extra/include/ui/GraphicBufferExtra.h
deleted file mode 100755
index ebe1654..0000000
--- a/gralloc_extra/include/ui/GraphicBufferExtra.h
+++ /dev/null
@@ -1,54 +0,0 @@
-#ifndef MTK_GRALLOC_EXTRA_GRAPHIC_BUFFER_EXTRA_H
-#define MTK_GRALLOC_EXTRA_GRAPHIC_BUFFER_EXTRA_H
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include <system/window.h>
-
-#include <utils/Singleton.h>
-#include <utils/RefBase.h>
-
-#include <hardware/gralloc_extra.h>
-
-namespace android {
-// ---------------------------------------------------------------------------
-class GraphicBuffer;
-
-class GraphicBufferExtra : public Singleton<GraphicBufferExtra>
-{
-public:
-    static inline GraphicBufferExtra& get() { return getInstance(); }
-
-    int query(buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_QUERY attribute, void *out_pointer);
-
-    int perform(buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_PERFORM attribute, void *in_pointer);
-#if 0
-    int free_sec(buffer_handle_t handle);
-#endif
-
-
-    /** Deprecated methods
-     * please use query/perform instead of using the following get/set methods.
-     */
-    int getIonFd(buffer_handle_t handle, int *idx, int *num);
-    int getBufInfo(buffer_handle_t handle, gralloc_buffer_info_t* bufInfo);
-    int getSecureBuffer(buffer_handle_t handle, int *type, int *hBuffer);
-    int setBufParameter(buffer_handle_t handle, int mask, int value);
-    int getMVA(buffer_handle_t handle, int32_t *mvaddr);
-    int setBufInfo(buffer_handle_t handle, const char * str);
-
-    ~GraphicBufferExtra();
-
-private:
-    friend class Singleton<GraphicBufferExtra>;
-
-    GraphicBufferExtra();
-
-    extra_device_t *mExtraDev;
-};
-
-// ---------------------------------------------------------------------------
-}; // namespace android
-
-#endif // MTK_GRALLOC_EXTRA_GRAPHIC_BUFFER_EXTRA_H
diff --git a/gralloc_extra/include/ui/gralloc_extra.h b/gralloc_extra/include/ui/gralloc_extra.h
deleted file mode 100755
index 8f7402e..0000000
--- a/gralloc_extra/include/ui/gralloc_extra.h
+++ /dev/null
@@ -1,337 +0,0 @@
-#ifndef MTK_GRALLOC_EXTRA_H
-#define MTK_GRALLOC_EXTRA_H
-
-#include <stdint.h>
-#include <sys/cdefs.h>
-#include <sys/types.h>
-
-#include <system/window.h>
-
-#include <hardware/gralloc.h>
-
-__BEGIN_DECLS
-
-enum {
-    GRALLOC_EXTRA_OK,
-    GRALLOC_EXTRA_UNKNOWN,
-    GRALLOC_EXTRA_NOT_SUPPORTED,
-    GRALLOC_EXTRA_NO_IMPLEMENTATION,
-    GRALLOC_EXTRA_NOT_INIT,
-    GRALLOC_EXTRA_INVALIDE_PARAMS,
-    GRALLOC_EXTRA_INVALIDE_OPERATION,
-    GRALLOC_EXTRA_ERROR,
-};
-
-typedef int GRALLOC_EXTRA_RESULT;
-
-/* enum for query() */
-typedef enum {
-    GRALLOC_EXTRA_GET_ION_FD = 1,    /* int */
-    GRALLOC_EXTRA_GET_FB_MVA,        /* uintptr_t, deprecated */
-    GRALLOC_EXTRA_GET_SECURE_HANDLE, /* uint32_t */
-
-    /* output: int */
-    GRALLOC_EXTRA_GET_WIDTH = 10,
-    GRALLOC_EXTRA_GET_HEIGHT,
-    GRALLOC_EXTRA_GET_STRIDE,
-    GRALLOC_EXTRA_GET_VERTICAL_STRIDE,
-    GRALLOC_EXTRA_GET_ALLOC_SIZE,
-    GRALLOC_EXTRA_GET_FORMAT,
-    GRALLOC_EXTRA_GET_USAGE,
-    GRALLOC_EXTRA_GET_VERTICAL_2ND_STRIDE,
-    GRALLOC_EXTRA_GET_BYTE_2ND_STRIDE,        
-
-    /* output: gralloc_extra_sf_info_t */
-    GRALLOC_EXTRA_GET_IOCTL_ION_SF_INFO = 100,
-
-    /* output: gralloc_extra_buf_debug_t */
-    GRALLOC_EXTRA_GET_IOCTL_ION_DEBUG,
-
-    /* output: uint32_t */
-    GRALLOC_EXTRA_GET_SECURE_HANDLE_HWC,
-
-    /* output: gralloc_rotate_info_t */
-    GRALLOC_EXTRA_GET_ROTATE_INFO,
-
-    /* output: gralloc_gpu_compression_info_t */
-    GRALLOC_EXTRA_GET_GPU_COMPRESSION_INFO,
-
-    /* output: gralloc_gpu_yuyv rotation */
-    GRALLOC_EXTRA_GET_ORIENTATION,
-    
-} GRALLOC_EXTRA_ATTRIBUTE_QUERY;
-
-/* enum for perform() */
-typedef enum {
-    /* input: gralloc_extra_sf_info_t * */
-    GRALLOC_EXTRA_SET_IOCTL_ION_SF_INFO = 100,
-
-    /* input: gralloc_extra_buf_debug_t * */
-    GRALLOC_EXTRA_SET_IOCTL_ION_DEBUG,
-
-    /* input: NULL */
-    GRALLOC_EXTRA_ALLOC_SECURE_BUFFER_HWC,
-    GRALLOC_EXTRA_FREE_SEC_BUFFER_HWC,
-
-    /* input: gralloc_gpu_yuyv rotation */
-    GRALLOC_EXTRA_SET_ORIENTATION,
-} GRALLOC_EXTRA_ATTRIBUTE_PERFORM;
-
-int gralloc_extra_query(buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_QUERY attribute, void *out_pointer);
-
-int gralloc_extra_perform(buffer_handle_t handle, GRALLOC_EXTRA_ATTRIBUTE_PERFORM attribute, void *in_pointer);
-
-int gralloc_extra_free_sec(buffer_handle_t handle);
-
-
-#define GRALLOC_EXTRA_MAKE_BIT(start_bit, index)        ( (index) << (start_bit) )
-#define GRALLOC_EXTRA_MAKE_MASK(start_bit, end_bit)     ( ( ((unsigned int)-1) >> (sizeof(int) * __CHAR_BIT__ - 1 - (end_bit) + (start_bit) ) ) << (start_bit) )
-
-#define GRALLOC_EXTRA_UNMAKE_BIT(start_bit, index)        ( (index) >> (start_bit) )
-
-
-/* bits in sf_info.status */
-enum {
-    /* TYPE: bit 0~1 */
-    GRALLOC_EXTRA_BIT_TYPE_CPU          = GRALLOC_EXTRA_MAKE_BIT(0,0),
-    GRALLOC_EXTRA_BIT_TYPE_GPU          = GRALLOC_EXTRA_MAKE_BIT(0,1),
-    GRALLOC_EXTRA_BIT_TYPE_VIDEO        = GRALLOC_EXTRA_MAKE_BIT(0,2),
-    GRALLOC_EXTRA_BIT_TYPE_CAMERA       = GRALLOC_EXTRA_MAKE_BIT(0,3),
-    GRALLOC_EXTRA_MASK_TYPE             = GRALLOC_EXTRA_MAKE_MASK(0,1),
-
-    /* UFO alignment: bit 2~3 Temporary add back to prevent 6795 build fail. 
-       Remove after 6795 SF/HWC finishes porting
-     */
-    GRALLOC_EXTRA_BIT_UFO_16_32         = GRALLOC_EXTRA_MAKE_BIT(2,1),
-    GRALLOC_EXTRA_BIT_UFO_32_32         = GRALLOC_EXTRA_MAKE_BIT(2,2),
-    GRALLOC_EXTRA_BIT_UFO_64_64         = GRALLOC_EXTRA_MAKE_BIT(2,3),
-    GRALLOC_EXTRA_MASK_UFO_ALIGN        = GRALLOC_EXTRA_MAKE_MASK(2,3),
-
-    /* ColorFormat: bit 2~6 */
-    GRALLOC_EXTRA_BIT_CM_YV12           = GRALLOC_EXTRA_MAKE_BIT(2,0),
-    GRALLOC_EXTRA_BIT_CM_YUYV           = GRALLOC_EXTRA_MAKE_BIT(2,1),
-    GRALLOC_EXTRA_BIT_CM_I420           = GRALLOC_EXTRA_MAKE_BIT(2,2),
-    GRALLOC_EXTRA_BIT_CM_NV12           = GRALLOC_EXTRA_MAKE_BIT(2,3),
-    GRALLOC_EXTRA_BIT_CM_YUV420_FLEX    = GRALLOC_EXTRA_MAKE_BIT(2,4),
-    GRALLOC_EXTRA_BIT_CM_NV12_BLK       = GRALLOC_EXTRA_MAKE_BIT(2,5),
-    GRALLOC_EXTRA_BIT_CM_NV12_BLK_FCM   = GRALLOC_EXTRA_MAKE_BIT(2,6),
-    GRALLOC_EXTRA_BIT_CM_UFO            = GRALLOC_EXTRA_MAKE_BIT(2,7),
-    GRALLOC_EXTRA_BIT_CM_PRIVATE        = GRALLOC_EXTRA_MAKE_BIT(2,8),
-    GRALLOC_EXTRA_BIT_CM_YV12_10BIT     = GRALLOC_EXTRA_MAKE_BIT(2,9),
-    GRALLOC_EXTRA_BIT_CM_YUYV_10BIT     = GRALLOC_EXTRA_MAKE_BIT(2,10),
-    GRALLOC_EXTRA_BIT_CM_I420_10BIT     = GRALLOC_EXTRA_MAKE_BIT(2,11),
-    GRALLOC_EXTRA_BIT_CM_YUV420_FLEX_10BIT      = GRALLOC_EXTRA_MAKE_BIT(2,12),
-    GRALLOC_EXTRA_BIT_CM_NV12_BLK_10BIT_H       = GRALLOC_EXTRA_MAKE_BIT(2,13),
-    GRALLOC_EXTRA_BIT_CM_NV12_BLK_10BIT_V       = GRALLOC_EXTRA_MAKE_BIT(2,14),
-    GRALLOC_EXTRA_BIT_CM_UFO_10BIT_H    = GRALLOC_EXTRA_MAKE_BIT(2,15),
-    GRALLOC_EXTRA_BIT_CM_UFO_10BIT_V    = GRALLOC_EXTRA_MAKE_BIT(2,16),
-    GRALLOC_EXTRA_BIT_CM_NV12_PRIVATE_10BIT     = GRALLOC_EXTRA_MAKE_BIT(2,17),
-    GRALLOC_EXTRA_MASK_CM               = GRALLOC_EXTRA_MAKE_MASK(2,6),
-
-    /* Secure switch: bit 7 */
-    GRALLOC_EXTRA_BIT_NORMAL            = GRALLOC_EXTRA_MAKE_BIT(7,0),
-    GRALLOC_EXTRA_BIT_SECURE            = GRALLOC_EXTRA_MAKE_BIT(7,1),
-    GRALLOC_EXTRA_MASK_SECURE           = GRALLOC_EXTRA_MAKE_MASK(7,7),
-
-    /* S3D Mode: bit 8~9 */
-    GRALLOC_EXTRA_BIT_S3D_2D            = GRALLOC_EXTRA_MAKE_BIT(8,0),
-    GRALLOC_EXTRA_BIT_S3D_SBS           = GRALLOC_EXTRA_MAKE_BIT(8,1),
-    GRALLOC_EXTRA_BIT_S3D_TAB           = GRALLOC_EXTRA_MAKE_BIT(8,2),
-    GRALLOC_EXTRA_MASK_S3D              = GRALLOC_EXTRA_MAKE_MASK(8,9),
-
-    /* DIRTY: bit 10, 11 */
-    GRALLOC_EXTRA_BIT_UNDIRTY           = GRALLOC_EXTRA_MAKE_BIT(10,0),
-    GRALLOC_EXTRA_BIT_DIRTY             = GRALLOC_EXTRA_MAKE_MASK(10,11),
-    GRALLOC_EXTRA_MASK_DIRTY            = GRALLOC_EXTRA_MAKE_MASK(10,11),
-    /* DIRTY: SF, 10 */
-    GRALLOC_EXTRA_BIT_SF_DIRTY          = GRALLOC_EXTRA_MAKE_MASK(10,10),
-    GRALLOC_EXTRA_MASK_SF_DIRTY         = GRALLOC_EXTRA_MAKE_MASK(10,10),
-    /* DIRTY: AUX, 11 */
-    GRALLOC_EXTRA_BIT_AUX_DIRTY         = GRALLOC_EXTRA_MAKE_MASK(11,11),
-    GRALLOC_EXTRA_MASK_AUX_DIRTY        = GRALLOC_EXTRA_MAKE_MASK(11,11),
-
-    /* Orientation: bit 12~15 */
-    GRALLOC_EXTRA_MASK_ORIENT           = GRALLOC_EXTRA_MAKE_MASK(12,15),
-
-    /* Alpha: bit 16~23 */
-    GRALLOC_EXTRA_MASK_ALPHA            = GRALLOC_EXTRA_MAKE_MASK(16,23),
-
-    /* Blending: bit 24~25 */
-    GRALLOC_EXTRA_MASK_BLEND            = GRALLOC_EXTRA_MAKE_MASK(24,25),
-
-    /* Dirty Param: bit 26 */
-    GRALLOC_EXTRA_MASK_DIRTY_PARAM      = GRALLOC_EXTRA_MAKE_MASK(26,26),
-
-    /* FLUSH: bit 27 */
-    GRALLOC_EXTRA_BIT_FLUSH             = GRALLOC_EXTRA_MAKE_BIT(27,0),
-    GRALLOC_EXTRA_BIT_NOFLUSH           = GRALLOC_EXTRA_MAKE_BIT(27,1),
-    GRALLOC_EXTRA_MASK_FLUSH            = GRALLOC_EXTRA_MAKE_MASK(27,27),
-
-    /* YUV Color SPACE: bit 29~31 */
-    GRALLOC_EXTRA_BIT_YUV_NOT_SET       = GRALLOC_EXTRA_MAKE_BIT(29,0),
-    GRALLOC_EXTRA_BIT_YUV_BT601_NARROW  = GRALLOC_EXTRA_MAKE_BIT(29,1),
-    GRALLOC_EXTRA_BIT_YUV_BT601_FULL    = GRALLOC_EXTRA_MAKE_BIT(29,2),
-    GRALLOC_EXTRA_BIT_YUV_BT709_NARROW  = GRALLOC_EXTRA_MAKE_BIT(29,3),
-    GRALLOC_EXTRA_BIT_YUV_BT709_FULL    = GRALLOC_EXTRA_MAKE_BIT(29,4),
-    GRALLOC_EXTRA_BIT_YUV_BT2020_NARROW = GRALLOC_EXTRA_MAKE_BIT(29,5),
-    GRALLOC_EXTRA_MASK_YUV_COLORSPACE   = GRALLOC_EXTRA_MAKE_MASK(29,31),
-};
-
-/* bits in sf_info.status2 */
-enum {
-    /* TYPE: bit 0~2 */
-    GRALLOC_EXTRA_BIT2_LAYER_NORMAL      = 0x0,
-    GRALLOC_EXTRA_BIT2_LAYER_NAV         = 0x1, // Navigation bar
-    GRALLOC_EXTRA_MASK2_LAYER_TYPE       = GRALLOC_EXTRA_MAKE_MASK(0,2),
-
-    /* YUY2 for Camera Rotation : bit 3~5 */
-    GRALLOC_EXTRA_BIT2_YUY2_ROT0            = GRALLOC_EXTRA_MAKE_BIT(3,0),
-    GRALLOC_EXTRA_BIT2_YUY2_R1_FLIP_H      = GRALLOC_EXTRA_MAKE_BIT(3,1),    
-    GRALLOC_EXTRA_BIT2_YUY2_R2_FLIP_V      = GRALLOC_EXTRA_MAKE_BIT(3,2),    
-    GRALLOC_EXTRA_BIT2_YUY2_R3_ROT180      = GRALLOC_EXTRA_MAKE_BIT(3,3),
-    GRALLOC_EXTRA_BIT2_YUY2_R4_ROT90       = GRALLOC_EXTRA_MAKE_BIT(3,4),
-    GRALLOC_EXTRA_BIT2_YUY2_R5              = GRALLOC_EXTRA_MAKE_BIT(3,5),
-    GRALLOC_EXTRA_BIT2_YUY2_R6              = GRALLOC_EXTRA_MAKE_BIT(3,6),
-    GRALLOC_EXTRA_BIT2_YUY2_R7_ROT270      = GRALLOC_EXTRA_MAKE_BIT(3,7),
-    GRALLOC_EXTRA_MASK2_YUY2_ROT            = GRALLOC_EXTRA_MAKE_MASK(3,5),
-    
-};
-
-typedef enum {
-    /* normal secure buffer */
-    GRALLOC_EXTRA_SECURE_BUFFER_TYPE_NORMAL,
-
-    /* zero-initialized secure buffer */
-    GRALLOC_EXTRA_SECURE_BUFFER_TYPE_ZERO
-} GRALLOC_EXTRA_SECURE_BUFFER_TYPE;
-
-typedef struct _crop_t {
-    int32_t x, y, w, h;
-
-#ifdef __cplusplus
-    _crop_t():x(0),y(0),w(0),h(0) {}
-#endif
-} _crop_t;
-
-/* extension data */
-typedef struct gralloc_extra_ion_sf_info_t {
-    /* magic number to make sure that obj is created by query() */
-    uint32_t magic;
-
-    /* used by SurfaceFlinger*/
-    _crop_t src_crop;
-    _crop_t dst_crop;
-
-    /* buffer flags, please change this value by sf_set_status() */
-    int32_t status;
-
-    /* used for pre-allocate buffer */
-    int32_t pool_id;
-
-    /* used for profiling latency */
-    uint32_t sequence;
-
-    /* secure handle allocated by GRALLOC_EXTRA_GET_SECURE_HANDLE_HWC */
-    uint32_t secure_handle_hwc;
-
-    /* used for video frame */
-    uint32_t timestamp;
-
-    /* buffer flags, please change this value by sf_set_status2() */
-    int32_t status2;
-
-    /* video buffer status
-       bit 31: valid bit, 0 = invalid (default), 1 = valid
-
-       bit 30-25: Y stride alignment
-       bit 24-19: CbCr stride alignment
-       bit 18-13: height alignment
-       alignment interpretation
-
-       Y:
-       y_align = (videobuffer_status & 0x7FFFFFFF) >> 25;
-       if (0 == y_align) y_align = 1;
-       else y_align *= 2;
-       CbCr:
-       cbcr_align = (videobuffer_status & 0x01FFFFFF) >> 19;
-       if (0 == cbcr_align) cbcr_align = 1;
-       else cbcr_align *= 2;
-       Height:
-       h_align = (videobuffer_status & 0x0007FFFF) >> 13;
-       if (0 == h_align) h_align = 1;
-       else h_align *= 2;
-
-       bit 12: deinterlace 0 = no, 1 = yes
-    */
-    int32_t videobuffer_status;
-
-#ifdef __cplusplus
-    gralloc_extra_ion_sf_info_t():
-        magic(0),src_crop(),dst_crop(),
-        status(0),pool_id(0),sequence(0),
-        secure_handle_hwc(0),
-        timestamp(0), status2(0)
-    {}
-#endif
-} gralloc_extra_ion_sf_info_t;
-
-int gralloc_extra_sf_set_status(gralloc_extra_ion_sf_info_t *sf_info, int32_t mask, int32_t value);
-
-int gralloc_extra_sf_set_status2(gralloc_extra_ion_sf_info_t *sf_info, int32_t mask, int32_t value);
-
-/* debug data, to facilitate information while debugging */
-typedef struct gralloc_extra_ion_debug_t {
-    int data[4];
-    char name[16];
-
-#ifdef __cplusplus
-    gralloc_extra_ion_debug_t():
-        data(),
-        name()
-    {}
-#endif
-} gralloc_extra_ion_debug_t;
-
-typedef struct gralloc_rotate_info_t {
-    //rotate
-    int rotate_mode;
-    int rotate_dx;
-    int rotate_dy;
-} gralloc_rotate_info_t;
-
-typedef struct gralloc_gpu_compression_info_t {
-    /* GPU info */
-    //UFO
-    unsigned char ufo_enable;
-    //unsigned int ufo_format;
-    //unsigned char ufo_is_linear;
-    unsigned int ufo_length_buffer_base;
-    unsigned char ufo_pattern_replace_en;
-    unsigned int ufo_pattern;
-} gralloc_gpu_compression_info_t;
-
-/* Deprecated methods and struct. START */
-typedef struct gralloc_buffer_info_t {
-    /* static number, never change */
-    int width;
-    int height;
-    int stride;
-    int format;
-    int vertical_stride;
-    int usage;
-
-    /* change by setBufParameter() */
-    int status;
-} gralloc_buffer_info_t;
-
-int gralloc_extra_getIonFd(buffer_handle_t handle, int *idx, int *num);
-int gralloc_extra_getBufInfo(buffer_handle_t handle, gralloc_buffer_info_t* bufInfo);
-int gralloc_extra_getSecureBuffer(buffer_handle_t handle, int *type, int *hBuffer);
-int gralloc_extra_setBufParameter(buffer_handle_t handle, int mask, int value);
-int gralloc_extra_getMVA(buffer_handle_t handle, int32_t *mvaddr);
-int gralloc_extra_setBufInfo(buffer_handle_t handle, const char * str);
-/* Deprecated methods and struct. END */
-
-__END_DECLS
-
-#endif /* MTK_GRALLOC_EXTRA_H */
diff --git a/gui_ext/Android.mk b/gui_ext/Android.mk
deleted file mode 100755
index f25cc12..0000000
--- a/gui_ext/Android.mk
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright Statement:
-#
-# This software/firmware and related documentation ("MediaTek Software") are
-# protected under relevant copyright laws. The information contained herein
-# is confidential and proprietary to MediaTek Inc. and/or its licensors.
-# Without the prior written permission of MediaTek inc. and/or its licensors,
-# any reproduction, modification, use or disclosure of MediaTek Software,
-# and information contained herein, in whole or in part, shall be strictly prohibited.
-
-# MediaTek Inc. (C) 2010. All rights reserved.
-#
-# BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-# THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-# RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
-# AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-# NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-# SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-# SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
-# THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
-# THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
-# CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
-# SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
-# STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
-# CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-# AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-# OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
-# MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-#
-# The following software/firmware and/or related documentation ("MediaTek Software")
-# have been modified by MediaTek Inc. All revisions are subject to any receiver's
-# applicable license agreements with MediaTek Inc.
-
-
-include $(call all-subdir-makefiles)
-
diff --git a/gui_ext/NOTICE b/gui_ext/NOTICE
deleted file mode 100755
index 0519ecb..0000000
--- a/gui_ext/NOTICE
+++ /dev/null
@@ -1 +0,0 @@
- 
\ No newline at end of file
diff --git a/gui_ext/README b/gui_ext/README
deleted file mode 100755
index ff42814..0000000
--- a/gui_ext/README
+++ /dev/null
@@ -1,37 +0,0 @@
-GuiExtService support the conversion pool to preallocate buffer for video playback
-
-WHAT IT DOES?
-=============
-
-Some processes notifies GuiExtService whether video is playing or not
-If yes, GuiExtService is going to preallocate buffer for the follow-up stages
-instead of allocating when needing buffers
-
-HOW IT WAS BUILT?
-==================
-
-It needs the following libs from AOSP:
-1.  libutils.so
-2.  libcutils.so
-3.  libbinder.so
-4.  libhardware.so
-5.  libhardware_legacy.so
-5.  libgui.so
-6.  libui.so
-7.  libdl.so
-8.  libion.so
-
-and the following libs from MediaTek:
-1.  libion_mtk.so
-2.  libgralloc_extra.so
-
-All source/dependency modules of this module are already put in
-'vendor/mediatek/proprietary/hardware/gui_ext/' folder.
-
-
-HOW TO USE IT?
-==============
-
-just link the libguiext.so
-
-All the source code of this library were written by MediaTek co..
diff --git a/gui_ext/inc/GuiExtClient.h b/gui_ext/inc/GuiExtClient.h
deleted file mode 100755
index 57f48eb..0000000
--- a/gui_ext/inc/GuiExtClient.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef __GUIEXT_SERVICE_CLIENT_H__
-#define __GUIEXT_SERVICE_CLIENT_H__
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include <binder/Binder.h>
-#include <utils/Singleton.h>
-#include <utils/StrongPointer.h>
-#include <utils/KeyedVector.h>
-
-#include "IGuiExtService.h"
-
-namespace android {
-
-class IGuiExtService;
-class GuiExtClient
-{
-protected:
-    GuiExtClient();
-    virtual ~GuiExtClient(){}
-
-    // DeathRecipient interface
-    void serviceDied();
-    virtual void serviceDiedLocked() = 0;
-
-    status_t assertStateLocked() const;
-
-    mutable Mutex mLock;
-    mutable sp<IGuiExtService> mGuiExtService;
-    mutable sp<IBinder::DeathRecipient> mDeathObserver;
-};
-
-};
-
-#endif
diff --git a/gui_ext/inc/GuiExtClientConsumer.h b/gui_ext/inc/GuiExtClientConsumer.h
deleted file mode 100755
index c30c27c..0000000
--- a/gui_ext/inc/GuiExtClientConsumer.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#ifndef __GUIEXT_SERVICE_CLIENT_CONSUMER_H__
-#define __GUIEXT_SERVICE_CLIENT_CONSUMER_H__
-
-#include "GuiExtClient.h"
-#include "GuiExtDataType.h"
-
-namespace android {
-
-class IGuiExtService;
-class GuiExtClientConsumer :
-        public GuiExtClient,
-        public Singleton<GuiExtClientConsumer>
-{
-    friend class Singleton<GuiExtClientConsumer>;
-
-public:
-    // acquire and release is used by consumer
-    status_t acquire(android_native_buffer_t** buffer, uint32_t poolId, uint32_t usage, uint32_t type = 0);
-    status_t release(android_native_buffer_t* buffer, uint32_t poolId, uint32_t usage, uint32_t type = 0);
-
-    // for release shadow GraphicBuffer reference
-    status_t disconnect(uint32_t poolId, uint32_t usage, uint32_t type = 0);
-    // for HWC to config multi-display information
-    status_t configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum = 3);
-    // check this buffer is in Shadow List or not
-    bool isValidBuffer(android_native_buffer_t* buffer);
-    // for dump shadow GraphicBuffer information
-    void dump(String8& result, char* buffer, size_t SIZE) const;
-
-private:
-    GuiExtClientConsumer();
-    virtual ~GuiExtClientConsumer();
-
-    // DeathRecipient interface
-    virtual void serviceDiedLocked();
-
-    class BufferSlot : public virtual RefBase {
-        public:
-            sp<GraphicBuffer> buffer;
-            uint32_t poolId;
-            uint32_t usage;
-            uint32_t type;
-            uint32_t idx;
-            bool isAcquired;
-    };
-
-    DefaultKeyedVector< uint32_t, sp<BufferSlot> > mSlots;
-
-    // private function
-    int getSlotFromBufferLocked(android_native_buffer_t* buffer) const;
-
-    status_t releaseLocked(android_native_buffer_t* buffer, uint32_t poolId, uint32_t usage, uint32_t type);
-};
-
-};
-
-#endif
diff --git a/gui_ext/inc/GuiExtClientProducer.h b/gui_ext/inc/GuiExtClientProducer.h
deleted file mode 100755
index d1c5e59..0000000
--- a/gui_ext/inc/GuiExtClientProducer.h
+++ /dev/null
@@ -1,29 +0,0 @@
-#ifndef __GUIEXT_SERVICE_CLIENT_PRODUCER_H__
-#define __GUIEXT_SERVICE_CLIENT_PRODUCER_H__
-
-#include "GuiExtClient.h"
-
-namespace android {
-
-class GuiExtClientProducer :
-        public GuiExtClient,
-        public Singleton<GuiExtClientProducer>
-{
-    friend class Singleton<GuiExtClientProducer>;
-
-public:
-    // IGuiExtServic interface
-    // alloc & free is used by producer
-    status_t alloc(uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *poolId);
-    status_t free(uint32_t poolId);
-protected:
-    GuiExtClientProducer();
-    virtual ~GuiExtClientProducer();
-
-    // DeathRecipient interface
-    virtual void serviceDiedLocked();
-};
-
-};
-
-#endif
diff --git a/gui_ext/inc/GuiExtDataType.h b/gui_ext/inc/GuiExtDataType.h
deleted file mode 100755
index 8bce74f..0000000
--- a/gui_ext/inc/GuiExtDataType.h
+++ /dev/null
@@ -1,14 +0,0 @@
-#ifndef __GUIEXT_DATAEYPE_H__
-#define __GUIEXT_DATAEYPE_H__
-
-enum {
-    GUI_EXT_USAGE_GPU = 0,
-    GUI_EXT_USAGE_HWC = 1,
-    GUI_EXT_USAGE_MAX
-};
-
-#endif
-
-
-
-
diff --git a/gui_ext/inc/GuiExtService.h b/gui_ext/inc/GuiExtService.h
deleted file mode 100755
index 5a1c635..0000000
--- a/gui_ext/inc/GuiExtService.h
+++ /dev/null
@@ -1,54 +0,0 @@
-#ifndef __GUIEXT_SERVICE_H__
-#define __GUIEXT_SERVICE_H__
-
-#include <utils/threads.h>
-#include "IGuiExtService.h"
-
-namespace android
-{
-
-class GuiExtPool;
-class String8;
-class GuiExtService :
-        public BinderService<GuiExtService>,
-        public BnGuiExtService
-//        public Thread
-{
-    friend class BinderService<GuiExtService>;
-public:
-
-    GuiExtService();
-    ~GuiExtService();
-
-    static char const* getServiceName() { return "GuiExtService"; }
-
-    // IGuiExtServic interface
-    virtual status_t alloc(const sp<IBinder>& token, uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *id);
-    virtual status_t free(uint32_t id);
-    virtual status_t acquire(const sp<IBinder>& token, uint32_t poolId, uint32_t usage, uint32_t type, int *buf);
-    virtual status_t request(uint32_t poolId, uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer);
-    virtual status_t release(uint32_t poolId, uint32_t usage, uint32_t type, int buf);
-    virtual status_t disconnect(uint32_t poolId, uint32_t usage, uint32_t type);
-    virtual status_t configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum);
-    virtual status_t dump(int fd, const Vector<String16>& args);
-
-    // to register/unregister dump tunnels to/from mDumpTunnels
-    virtual status_t regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
-    virtual status_t unregDump(const String8& key);
-
-private:
-//    virtual void onFirstRef();
-//    virtual status_t readyToRun();
-//    virtual bool threadLoop();
-
-    mutable Mutex mLock;
-    sp<GuiExtPool> mPool;
-
-    // maintain a table to store all dump tunnels
-    // each tunnel's key has a prefix which presents types of tunnels
-    // ex: BQ-... this is a dump tunnel for BQ
-    mutable Mutex mDumpLock;
-    KeyedVector<String8, sp<IDumpTunnel> > mDumpTunnels;
-};
-};
-#endif
diff --git a/gui_ext/inc/IGuiExtService.h b/gui_ext/inc/IGuiExtService.h
deleted file mode 100755
index bd9b6d2..0000000
--- a/gui_ext/inc/IGuiExtService.h
+++ /dev/null
@@ -1,71 +0,0 @@
-#ifndef __IGUIEXTSERVICE_H__
-#define __IGUIEXTSERVICE_H__
-
-#include <binder/IInterface.h>
-#include <binder/Parcel.h>
-#include <binder/BinderService.h>
-
-#include <gui/IGraphicBufferAlloc.h>
-
-namespace android
-{
-//
-//  Holder service for pass objects between processes.
-//
-
-class IDumpTunnel;
-class String8;
-
-class IGuiExtService : public IInterface
-{
-protected:
-    enum {
-        GUI_EXT_ALLOC = IBinder::FIRST_CALL_TRANSACTION,
-        GUI_EXT_FREE,
-        GUI_EXT_ACQUIRE,
-        GUI_EXT_REQUEST,
-        GUI_EXT_RELEASE,
-        GUI_EXT_DISCONNECT,
-        GUI_EXT_CONFIGDISPLAY,
-        GUI_EXT_REGDUMP,
-        GUI_EXT_UNREGDUMP
-    };
-
-public:
-    DECLARE_META_INTERFACE(GuiExtService);
-
-    virtual status_t alloc(const sp<IBinder>& token, uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *id) = 0;
-    virtual status_t free(uint32_t id) = 0;
-    virtual status_t acquire(const sp<IBinder>& token, uint32_t poolId, uint32_t usage, uint32_t type, int *buf) = 0;
-    virtual status_t request(uint32_t poolId, uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer) = 0;
-    virtual status_t release(uint32_t poolId, uint32_t usage, uint32_t type, int buf) = 0;
-    virtual status_t disconnect(uint32_t poolId, uint32_t usage, uint32_t type) = 0;
-    virtual status_t configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum) = 0;
-
-    // for dump tunnel
-    virtual status_t regDump(const sp<IDumpTunnel>& tunnel, const String8& key) = 0;
-    virtual status_t unregDump(const String8& key) = 0;
-};
-
-class BnGuiExtService : public BnInterface<IGuiExtService>
-{
-    virtual status_t onTransact(uint32_t code,
-                                const Parcel& data,
-                                Parcel* reply,
-                                uint32_t flags = 0);
-};
-
-// an easy way to check and get the GuiExtService without blocking
-sp<IGuiExtService> checkGuiExtService();
-};
-
-using namespace android;
-
-extern "C"
-{
-    // The circular link must be broken because libgui.so and libgui_ext.so needs to link each other
-    // libgui.so uses dlopen() to load libgui_ext.so at runtime
-    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
-    bool unregDump(const String8& key);
-}
-#endif
diff --git a/gui_ext/lib/Android.mk b/gui_ext/lib/Android.mk
deleted file mode 100755
index 7984282..0000000
--- a/gui_ext/lib/Android.mk
+++ /dev/null
@@ -1,89 +0,0 @@
-# Copyright Statement:
-#
-# This software/firmware and related documentation ("MediaTek Software") are
-# protected under relevant copyright laws. The information contained herein
-# is confidential and proprietary to MediaTek Inc. and/or its licensors.
-# Without the prior written permission of MediaTek inc. and/or its licensors,
-# any reproduction, modification, use or disclosure of MediaTek Software,
-# and information contained herein, in whole or in part, shall be strictly prohibited.
-#
-# MediaTek Inc. (C) 2010. All rights reserved.
-#
-# BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-# THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-# RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
-# AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-# NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-# SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-# SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
-# THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
-# THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
-# CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
-# SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
-# STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
-# CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-# AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-# OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
-# MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-#
-# The following software/firmware and/or related documentation ("MediaTek Software")
-# have been modified by MediaTek Inc. All revisions are subject to any receiver's
-# applicable license agreements with MediaTek Inc.
-
-#
-# libgui_extra.so
-# modified by daniel_hk(https://github.com/daniel_hk)
-
-LOCAL_PATH:= $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    IGuiExtService.cpp \
-    GuiExtService.cpp \
-    GuiExtClient.cpp \
-    GuiExtClientProducer.cpp \
-    GuiExtClientConsumer.cpp \
-    GuiExtImpl.cpp
-
-MTK_HWC_CHIP = $(shell echo $(MTK_PLATFORM) | tr A-Z a-z )
-
-LOCAL_C_INCLUDES:= \
-    $(TOP)/frameworks/base/include/ \
-    $(TOP)/device/vernee/apollo_lite/gui_ext/inc \
-    $(TOP)/device/vernee/apollo_lite/ui_ext/inc \
-    $(TOP)/device/vernee/apollo_lite/gralloc_extra/include
-
-LOCAL_SHARED_LIBRARIES := \
-    libutils \
-    libcutils \
-    libbinder \
-    libhardware \
-    libhardware_legacy \
-    libgui \
-    libui \
-    libdl \
-    libion \
-    libion_mtk \
-    libgralloc_extra \
-    libui_ext
-
-# for bring up, please unmark this line
-# LOCAL_CFLAGS += -DMTK_DO_NOT_USE_GUI_EXT
-
-ifneq ($(strip $(TARGET_BUILD_VARIANT)), eng)
-LOCAL_CFLAGS += -DMTK_USER_BUILD
-endif
-
-ifeq ($(MTK_MIRAVISION_SUPPORT),yes)
-LOCAL_CFLAGS += -DCONFIG_FOR_SOURCE_PQ
-endif
-
-LOCAL_MODULE := libgui_ext
-
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_SHARED_LIBRARY)
-
diff --git a/gui_ext/lib/GuiExtClient.cpp b/gui_ext/lib/GuiExtClient.cpp
deleted file mode 100755
index 2ce44b3..0000000
--- a/gui_ext/lib/GuiExtClient.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-#define LOG_TAG "GuiExt"
-
-#define MTK_LOG_ENABLE 1
-#include <cutils/log.h>
-#include <binder/IServiceManager.h>
-#include <binder/ProcessState.h>
-#include "GuiExtClient.h"
-#include "IGuiExtService.h"
-
-namespace android {
-
-#define GUIEX_LOGV(x, ...) ALOGV("[GuiExtL] " x, ##__VA_ARGS__)
-#define GUIEX_LOGD(x, ...) ALOGD("[GuiExtL] " x, ##__VA_ARGS__)
-#define GUIEX_LOGI(x, ...) ALOGI("[GuiExtL] " x, ##__VA_ARGS__)
-#define GUIEX_LOGW(x, ...) ALOGW("[GuiExtL] " x, ##__VA_ARGS__)
-#define GUIEX_LOGE(x, ...) ALOGE("[GuiExtL] " x, ##__VA_ARGS__)
-
-GuiExtClient::GuiExtClient()
-{
-    assertStateLocked();
-}
-
-status_t GuiExtClient::assertStateLocked() const
-{
-#ifndef MTK_DO_NOT_USE_GUI_EXT
-    if (mGuiExtService == NULL) {
-        mGuiExtService = checkGuiExtService();
-        if (mGuiExtService == NULL) {
-            return NAME_NOT_FOUND;
-        }
-
-        class DeathObserver : public IBinder::DeathRecipient {
-            GuiExtClient & mGuiExtClient;
-            virtual void binderDied(const wp<IBinder>& who) {
-                ALOGW("GuiEx Service died [%p]", who.unsafe_get());
-                mGuiExtClient.serviceDied();
-            }
-        public:
-            DeathObserver(GuiExtClient & service) : mGuiExtClient(service) { }
-        };
-        mDeathObserver = new DeathObserver(*const_cast<GuiExtClient*>(this));
-        mGuiExtService->asBinder(mGuiExtService)->linkToDeath(mDeathObserver);
-    }
-
-    return NO_ERROR;
-#else // MTK_DO_NOT_USE_GUI_EXT
-    return NO_INIT;
-#endif // MTK_DO_NOT_USE_GUI_EXT
-}
-
-void GuiExtClient::serviceDied()
-{
-    Mutex::Autolock _l(mLock);
-    GUIEX_LOGI("[%s]", __func__);
-
-    serviceDiedLocked();
-
-    mGuiExtService.clear();
-}
-};
diff --git a/gui_ext/lib/GuiExtClientConsumer.cpp b/gui_ext/lib/GuiExtClientConsumer.cpp
deleted file mode 100755
index e0e7e98..0000000
--- a/gui_ext/lib/GuiExtClientConsumer.cpp
+++ /dev/null
@@ -1,285 +0,0 @@
-#define LOG_TAG "GuiExt"
-
-#define MTK_LOG_ENABLE 1
-#include <cutils/log.h>
-#include <binder/IServiceManager.h>
-#include <binder/ProcessState.h>
-#include <hardware/hwcomposer_defs.h>
-
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-
-#include "GuiExtClientConsumer.h"
-#include "GuiExtDataType.h"
-
-namespace android {
-
-#define GUIEXT_LOGV(x, ...) ALOGV("[GuiExtC] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGD(x, ...) ALOGD("[GuiExtC] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGI(x, ...) ALOGI("[GuiExtC] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGW(x, ...) ALOGW("[GuiExtC] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGE(x, ...) ALOGE("[GuiExtC] " x, ##__VA_ARGS__)
-
-#define POOL_ID_SHIFT(id)           (id << 10)
-#define POOL_USAGE_SHIFT(usage)     (usage << 6)
-#define POOL_TYPE_SHIFT(type)       (type << 3)
-#define POOL_COMBINED_ID(id, usage, type, idx)   (POOL_ID_SHIFT(id)|POOL_USAGE_SHIFT(usage)|POOL_TYPE_SHIFT(type)|idx)
-
-ANDROID_SINGLETON_STATIC_INSTANCE(GuiExtClientConsumer);
-
-GuiExtClientConsumer::GuiExtClientConsumer()
-    : mSlots(NULL)
-{
-    assertStateLocked();
-}
-
-GuiExtClientConsumer::~GuiExtClientConsumer()
-{
-}
-
-void GuiExtClientConsumer::serviceDiedLocked()
-{
-    GUIEXT_LOGI("[%s]", __func__);
-
-    mSlots.clear();
-}
-
-status_t GuiExtClientConsumer::acquire(android_native_buffer_t** buffer, uint32_t poolId, uint32_t usage, uint32_t type)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-
-    if (usage >= GUI_EXT_USAGE_MAX) {
-        GUIEXT_LOGE("[%s] usage=%x is not support", __func__, usage);
-        *buffer = NULL;
-        return BAD_VALUE;
-    }
-
-    if (type > HWC_DISPLAY_VIRTUAL) {
-        GUIEXT_LOGE("[%s] type=%d is not support", __func__, type);
-        *buffer = NULL;
-        return BAD_VALUE;
-    }
-
-    err = assertStateLocked();
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("[%s] assertStateLocked fail", __func__);
-        *buffer = NULL;
-        return err;
-    }
-
-    GUIEXT_LOGV("acquire +, poolId=%d, usage=%x, type=%d", poolId, usage, type);
-    int buf = -1;
-    static sp<BBinder> sLife = new BBinder();
-
-    err = mGuiExtService->acquire(sLife, poolId, usage, type, &buf);
-    if (err < 0) {
-        for (uint32_t i = 0; i < mSlots.size(); i++) {
-            if (mSlots[i] != NULL &&
-                mSlots[i]->poolId == poolId &&
-                mSlots[i]->usage == usage &&
-                mSlots[i]->type == type &&
-                !mSlots[i]->isAcquired) {
-                mSlots[i]->isAcquired = true;
-                *buffer = mSlots[i]->buffer.get();
-                GUIEXT_LOGW("acquire fail=%d but find backup buffer: (poolId=%d, usage=%x, type=%d, idx=%d, buffer=%p) fail=%d",
-                    err, poolId, usage, type, mSlots[i]->idx, *buffer);
-                return NO_ERROR;
-            }
-        }
-
-        GUIEXT_LOGE("acquire fail: (poolId=%d, usage=%x, type=%d) fail=%d", poolId, usage, type, err);
-        *buffer = NULL;
-        return err;
-    }
-
-    GUIEXT_LOGV("acquire done, poolId=%d, usage=%x, type=%d, buf=%d", poolId, usage, type, buf);
-
-    uint32_t combine_id = POOL_COMBINED_ID(poolId, usage, type, buf);
-    sp<BufferSlot> slot = mSlots.valueFor(combine_id);
-    if (slot == 0) {
-        slot = new BufferSlot();
-        sp<GraphicBuffer> gbuf = slot->buffer;
-        slot->poolId = poolId;
-        slot->usage = usage;
-        slot->type = type;
-        slot->idx = buf;
-        slot->isAcquired = true;
-        err = mGuiExtService->request(poolId, usage, type, buf, &gbuf);
-        if (err != NO_ERROR) {
-            ALOGE("acquire: request failed: %d", err);
-            *buffer = NULL;
-            return err;
-        }
-        slot->buffer = gbuf;
-        GUIEXT_LOGV("request done, poolId=%d, usage=%x, type=%d, buf=%d, buffer=%p, slot id=%x",
-            poolId, usage, type, buf, slot->buffer.get(), combine_id);
-
-        mSlots.add(combine_id, slot);
-    } else
-        GUIEXT_LOGV("acquire an exist shadow buffer, poolId=%d, usage=%x, type=%d, buf=%d, buffer=%p, slot id=%x",
-            poolId, usage, type, buf, *buffer, combine_id);
-
-    *buffer = slot->buffer.get();
-
-    GUIEXT_LOGV("acquire -, poolId=%d, usage=%x, type=%d, buf=%d, buffer=%p", poolId, usage, type, buf, *buffer);
-
-    return NO_ERROR;
-}
-
-status_t GuiExtClientConsumer::release(android_native_buffer_t* buffer, uint32_t poolId, uint32_t usage, uint32_t type)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-
-    if (usage >= GUI_EXT_USAGE_MAX) {
-        GUIEXT_LOGE("[%s] usage=%x is not support", __func__, usage);
-        return BAD_VALUE;
-    }
-
-    if (type > HWC_DISPLAY_VIRTUAL) {
-        GUIEXT_LOGE("[%s] type=%d is not support", __func__, type);
-        return BAD_VALUE;
-    }
-
-    err = assertStateLocked();
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("[%s] assertStateLocked fail", __func__);
-        return err;
-    }
-
-    if (buffer == NULL) {
-        GUIEXT_LOGW("[%s] release fail, buffer is NULL", __func__);
-        return BAD_VALUE;
-    }
-
-    return releaseLocked(buffer, poolId, usage, type);
-}
-
-int GuiExtClientConsumer::getSlotFromBufferLocked(
-        android_native_buffer_t* buffer) const {
-    for (uint32_t i = 0; i < mSlots.size(); i++) {
-        if (mSlots[i] != NULL && mSlots[i]->buffer->handle == buffer->handle) {
-            return mSlots[i]->idx;
-        }
-    }
-    GUIEXT_LOGW("getSlotFromBufferLocked: unknown buffer: %p", buffer);
-    return BAD_VALUE;
-}
-
-status_t GuiExtClientConsumer::releaseLocked(android_native_buffer_t* buffer, uint32_t poolId, uint32_t usage, uint32_t type)
-{
-    int idx = getSlotFromBufferLocked(buffer);
-    if (idx < 0) {
-        GUIEXT_LOGE("releaseLocked fail, poolId=%d, usage=%x, type=%d, idx=%d", poolId, usage, type, idx);
-        return idx;
-    }
-
-    uint32_t combine_id = POOL_COMBINED_ID(poolId, usage, type, idx);
-
-    GUIEXT_LOGV("releaseLocked, poolId=%d, usage=%x, type=%d, idx=%d, slot id=%x", poolId, usage, type, idx, combine_id);
-
-    sp<BufferSlot> slot = mSlots.valueFor(combine_id);
-    if (slot != 0)
-        slot->isAcquired = false;
-    else
-        GUIEXT_LOGW("releaseLocked, can't find shadow buffer, slot id=%x", combine_id);
-
-    return mGuiExtService->release(poolId, usage, type, idx);
-}
-
-status_t GuiExtClientConsumer::disconnect(uint32_t poolId, uint32_t usage, uint32_t type)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-
-    if (usage >= GUI_EXT_USAGE_MAX) {
-        GUIEXT_LOGE("[%s] usage=%x is not support", __func__, usage);
-        return BAD_VALUE;
-    }
-
-    if (type > HWC_DISPLAY_VIRTUAL) {
-        GUIEXT_LOGE("[%s] type=%d is not support", __func__, type);
-        return BAD_VALUE;
-    }
-
-    err = assertStateLocked();
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("[%s] assertStateLocked fail", __func__);
-        return err;
-    }
-
-    GUIEXT_LOGV("disconnect, poolId=%d, usage=%x, type=%d", poolId, usage, type);
-
-    uint32_t size = mSlots.size();
-    if (size == 0) {
-        GUIEXT_LOGE("[%s] slot size is zero, no need to disconnect", __func__);
-        return BAD_VALUE;
-    }
-    for (uint32_t i = size-1;; i--) {
-        if (mSlots[i] != NULL && mSlots[i]->poolId == poolId && mSlots[i]->usage == usage && mSlots[i]->type == type) {
-            uint32_t idx = mSlots[i]->idx;
-            GUIEXT_LOGI("disconnect, find poolId=%d, usage=%x, type=%d, index=%d, isAcquired=%d",
-                poolId, usage, type, idx, mSlots[i]->isAcquired);
-            if (mSlots[i]->isAcquired)
-                releaseLocked(mSlots[i]->buffer.get(), poolId, usage, type);
-            uint32_t combine_id = POOL_COMBINED_ID(poolId, usage, type, idx);
-
-            mSlots.removeItem(combine_id);
-        }
-
-        if (i == 0)
-            break;
-    }
-
-    return mGuiExtService->disconnect(poolId, usage, type);
-}
-
-status_t GuiExtClientConsumer::configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-
-    err = assertStateLocked();
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("[%s] assertStateLocked fail", __func__);
-        return err;
-    }
-
-    return mGuiExtService->configDisplay(type, enable, w, h, bufNum);
-}
-
-bool GuiExtClientConsumer::isValidBuffer(android_native_buffer_t* buffer)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-
-    int idx = getSlotFromBufferLocked(buffer);
-    if (idx < 0) {
-        GUIEXT_LOGW("isValidBuffer return false for buffer=%p", buffer);
-        return false;
-    }
-
-    return true;
-}
-
-void GuiExtClientConsumer::dump(String8& result, char* /*buffer*/, size_t /*SIZE*/) const
-{
-    uint32_t slotSize = mSlots.size();
-    result.appendFormat("  -- GuiExtClientConsumer Info --\n"
-                        "   Shadow Buffer Size=%d\n"
-                        "--------------------------------\n", slotSize);
-
-    for (uint32_t i = 0; i < slotSize; i++) {
-        sp<BufferSlot> slot = mSlots[i];
-        ANativeWindowBuffer* abuf = slot->buffer.get();
-        result.appendFormat("      slot[%d], pool id=%d, usage=%d, type=%d, idx=%d, isAcquired=%d\n"
-                            "        gb[ptr=%p, w=%d, h=%d, fmt=%x]\n", i,
-                            slot->poolId, slot->usage, slot->type, slot->idx, slot->isAcquired,
-                            abuf, abuf->width, abuf->height, abuf->format);
-    }
-
-    result.appendFormat("--------------------------------\n");
-}
-
-};
diff --git a/gui_ext/lib/GuiExtClientProducer.cpp b/gui_ext/lib/GuiExtClientProducer.cpp
deleted file mode 100755
index 90ffa2b..0000000
--- a/gui_ext/lib/GuiExtClientProducer.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-#define LOG_TAG "GuiExt"
-
-#define MTK_LOG_ENABLE 1
-#include <cutils/log.h>
-#include <binder/IServiceManager.h>
-#include <binder/ProcessState.h>
-#include "GuiExtClientProducer.h"
-
-namespace android {
-
-#define GUIEXT_LOGV(x, ...) ALOGV("[GuiExtP] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGD(x, ...) ALOGD("[GuiExtP] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGI(x, ...) ALOGI("[GuiExtP] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGW(x, ...) ALOGW("[GuiExtP] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGE(x, ...) ALOGE("[GuiExtP] " x, ##__VA_ARGS__)
-
-ANDROID_SINGLETON_STATIC_INSTANCE(GuiExtClientProducer);
-
-GuiExtClientProducer::GuiExtClientProducer()
-{
-    assertStateLocked();
-}
-
-GuiExtClientProducer::~GuiExtClientProducer()
-{
-}
-
-void GuiExtClientProducer::serviceDiedLocked()
-{
-    GUIEXT_LOGI("[%s]", __func__);
-}
-
-status_t GuiExtClientProducer::alloc(uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *poolId)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-    err = assertStateLocked();
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("[%s] assertStateLocked fail", __func__);
-        return err;
-    }
-
-    GUIEXT_LOGV("alloc +, gralloc_usage=%x, w=%d, h=%d", gralloc_usage, w, h);
-    static sp<BBinder> sLife = new BBinder();
-    err = mGuiExtService->alloc(sLife, gralloc_usage, w, h, poolId);
-    GUIEXT_LOGV("alloc -, poolId=%d", *poolId);
-
-    return err;
-}
-
-status_t GuiExtClientProducer::free(uint32_t poolId)
-{
-    status_t err;
-    Mutex::Autolock _l(mLock);
-    err = assertStateLocked();
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("[%s] assertStateLocked fail", __func__);
-        return err;
-    }
-
-    GUIEXT_LOGV("free +, poolId=%d", poolId);
-    err = mGuiExtService->free(poolId);
-    GUIEXT_LOGV("free -, poolId=%d, ret=%d", poolId, err);
-
-    return err;
-}
-
-};
diff --git a/gui_ext/lib/GuiExtImpl.cpp b/gui_ext/lib/GuiExtImpl.cpp
deleted file mode 100755
index f82e5f8..0000000
--- a/gui_ext/lib/GuiExtImpl.cpp
+++ /dev/null
@@ -1,953 +0,0 @@
-#define LOG_TAG "GuiExt"
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#define MTK_LOG_ENABLE 1
-#include <dlfcn.h>
-#include <stdlib.h>
-#include <utils/Timers.h>
-#include <utils/Trace.h>
-#include <cutils/log.h>
-#include <cutils/properties.h>
-#include <math.h>
-
-#include <ui/DisplayInfo.h>
-#include <ui/GraphicBuffer.h>
-#include <gui/Surface.h>
-#include <gui/IProducerListener.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/SurfaceComposerClient.h>
-#include <gui/CpuConsumer.h>
-#include <hardware/gralloc.h>
-#include <hardware/hwcomposer_defs.h>
-#include <binder/IInterface.h>
-#include <binder/IPCThreadState.h>
-
-#include <hardware/gralloc_extra.h>
-
-#ifdef TOUCH_ION_BUFFER
-#include <linux/ion_drv.h>
-#include <ion/ion.h>
-#endif
-
-#include "GuiExtImpl.h"
-#include "GuiExtDataType.h"
-
-#include "graphics_mtk_defs.h"
-#include "gralloc_mtk_defs.h"
-
-#ifdef CONFIG_FOR_SOURCE_PQ
-#include <sys/ioctl.h>
-#include <linux/disp_session.h>
-#endif
-
-namespace android {
-
-#define GUIEXT_LOGV(x, ...) ALOGV("[GuiExtI] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGD(x, ...) ALOGD("[GuiExtI] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGI(x, ...) ALOGI("[GuiExtI] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGW(x, ...) ALOGW("[GuiExtI] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGE(x, ...) ALOGE("[GuiExtI] " x, ##__VA_ARGS__)
-
-#define ION_DEV_NODE "/dev/ion"
-
-#define MAX_ALLOC_SIZE          10
-#define MAX_GLES_DEQUEUED_NUM   3
-#define MAX_HWC_DEQUEUED_NUM    3
-#define LOCK_FOR_USAGE          (GRALLOC_USAGE_SW_READ_RARELY | GRALLOC_USAGE_SW_WRITE_NEVER | GRALLOC_USAGE_HW_TEXTURE)
-#define GUIEXT_ION_CLIENT_ID    0
-
-#define POOL_USAGE_SHIFT(usage)     (usage << 6)
-#define POOL_TYPE_SHIFT(type)     (type << 3)
-#define POOL_COMBINED_ID(usage, type, idx)   (POOL_USAGE_SHIFT(usage)|POOL_TYPE_SHIFT(type)|idx)
-
-const char* szUsageName[2] = {"GuiExt_Gpu", "GuiExt_Hwc"};
-const char* szDisplayType[HWC_NUM_DISPLAY_TYPES] = {"Primary", "External", "Virtual"};
-
-uint32_t gAcquiredFormat[GUI_EXT_USAGE_MAX] = {HAL_PIXEL_FORMAT_YV12, HAL_PIXEL_FORMAT_YUYV};
-
-#ifdef CONFIG_FOR_SOURCE_PQ
-class DispDevice: public Singleton<DispDevice>
-{
-    int mDevFd;
-    int mVideoRefCount;
-    disp_caps_info mCaps;
-
-public:
-    DispDevice();
-    ~DispDevice();
-
-    status_t setOverlaySessionMode(DISP_MODE mode);
-    uint32_t getPqNum() const {
-        if (mCaps.max_pq_num == 0) {
-            GUIEXT_LOGE("[PQ] Failed to get num of PQ");
-        }
-
-        return mCaps.max_pq_num;
-    }
-};
-
-ANDROID_SINGLETON_STATIC_INSTANCE(DispDevice);
-
-DispDevice::DispDevice()
-    : mDevFd(-1)
-    , mVideoRefCount(0)
-{
-    memset(&mCaps, 0, sizeof(disp_caps_info));
-
-    char filename[256];
-    mDevFd = open(filename, O_RDONLY);
-    sprintf(filename, "/dev/%s", DISP_SESSION_DEVICE);
-    if (mDevFd < 0) {
-        GUIEXT_LOGE("[PQ] Failed to open display device(%s): fd=%d", filename, mDevFd);
-    } else {
-        GUIEXT_LOGD("[PQ] open display device(%s) successfully", filename);
-        int err = ioctl(mDevFd, DISP_IOCTL_GET_DISPLAY_CAPS, &mCaps);
-        if (err < 0) {
-            GUIEXT_LOGE("[PQ] Failed to get disp capability err=%d", err);
-        }
-    }
-}
-
-DispDevice::~DispDevice()
-{
-    if (mDevFd >= 0)
-        close(mDevFd);
-}
-
-status_t DispDevice::setOverlaySessionMode(DISP_MODE mode)
-{
-    const bool decouple = (mode == DISP_SESSION_DECOUPLE_MODE);
-    GUIEXT_LOGD("[PQ] decouple=%d, VideoRefCnt=%d \n", decouple, mVideoRefCount);
-
-    mVideoRefCount = decouple ? mVideoRefCount + 1: mVideoRefCount - 1;
-    // If not the first VP start or last VP end, do nothing
-    if ( !((mVideoRefCount == 1 && decouple) || (mVideoRefCount == 0 && !decouple)) ) {
-        return NO_ERROR;
-    }
-
-    GUIEXT_LOGD("[PQ] Dynamic Switch to (mode=%d)", mode);
-
-    disp_session_config config;
-    memset(&config, 0, sizeof(disp_session_config));
-    config.device_id  = HWC_DISPLAY_PRIMARY;
-    config.type = DISP_SESSION_PRIMARY;
-    config.session_id = MAKE_DISP_SESSION(config.type, config.device_id);
-    config.mode       = mode;
-    config.user       = SESSION_USER_GUIEXT;
-
-    int err = ioctl(mDevFd, DISP_IOCTL_SET_SESSION_MODE, &config);
-    if (err < 0)
-    {
-        GUIEXT_LOGE("[PQ] Failed to set DispSession (mode=%d, errno:%d)!!", mode, err);
-        return BAD_VALUE;
-    }
-    return NO_ERROR;
-}
-#endif // CONFIG_FOR_SOURCE_PQ
-
-// --------------------------------------------------------
-
-GuiExtPool::GuiExtPool()
-    : mPoolId(0)
-    , mPoolList(NULL)
-    , mDefaultDisplayWidth(0)
-    , mDefaultDisplayHeight(0)
-{
-    GUIEXT_LOGI("GuiExtPool ctor");
-}
-
-GuiExtPool::~GuiExtPool()
-{
-}
-
-status_t GuiExtPool::alloc(const sp<IBinder>& token, uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t * poolId)
-{
-    Mutex::Autolock _l(mLock);
-    ATRACE_CALL();
-    GUIEXT_LOGD("  alloc, gralloc_usage=%x, w=%d, h=%d", gralloc_usage, w, h);
-
-    const nsecs_t time_start = systemTime();
-
-    uint32_t size = mPoolList.size();
-    if (size >= MAX_ALLOC_SIZE) {
-        GUIEXT_LOGW("  alloc pools size is reaching %d, can't alloc", size);
-        *poolId = 0;
-        return NOT_ENOUGH_DATA;
-    }
-
-    if (size == 0) {
-        DisplayInfo dinfo;
-        sp<IBinder> display = SurfaceComposerClient::getBuiltInDisplay(
-                ISurfaceComposer::eDisplayIdMain);
-        SurfaceComposerClient::getDisplayInfo(display, &dinfo);
-
-        mDefaultDisplayWidth = dinfo.w;
-        mDefaultDisplayHeight = dinfo.h;
-
-        sp<DispInfo> disp = new DispInfo;
-        disp->type = 0;
-        disp->w = mDefaultDisplayWidth;
-        disp->h = mDefaultDisplayHeight;
-        disp->bufNum = MAX_HWC_DEQUEUED_NUM;
-        mDisplayList.add((uint32_t)HWC_DISPLAY_PRIMARY, disp);
-
-        GUIEXT_LOGI("pool list size=0, try to get default display(w x h) = (%d x %d)", disp->w, disp->h);
-    }
-
-    *poolId = getPoolId();
-    bool isHwcNeeded = gralloc_usage & GRALLOC_USAGE_HW_COMPOSER;
-
-    class ProducerDeathObserver : public IBinder::DeathRecipient {
-        GuiExtPool & mPool;
-        virtual void binderDied(const wp<IBinder>& who) {
-            uint32_t size = mPool.mPoolList.size();
-            GUIEXT_LOGI("producer died, pool size=%d, binder ptr=[%p]", size, who.unsafe_get());
-
-            if (size == 0) {
-                GUIEXT_LOGV("producer died [%p], pool size is zero", who.unsafe_get());
-            } else {
-                for (uint32_t i = size-1 ;; i--) {
-                    GUIEXT_LOGV("   [p] compare index[%d], p=[%p]", i, mPool.mPoolList[i]->mProducerToken.get());
-                    if (mPool.mPoolList[i]->mProducerToken.get() == who.unsafe_get()) {
-                        GUIEXT_LOGW("   [p] found index[%d], p=[%p], id=%d", i, mPool.mPoolList[i]->mProducerToken.get(), mPool.mPoolList[i]->mId);
-                        mPool.mPoolList[i]->mProducerToken = NULL;
-                        mPool.mPoolList[i]->mProducerPid = -1;
-                        mPool.removePoolItem(mPool.mPoolList[i]->mId);
-                    }
-
-                    if (i == 0)
-                        break;
-                }
-
-                GUIEXT_LOGV("producer died done");
-            }
-        }
-    public:
-        ProducerDeathObserver(GuiExtPool & pool) : mPool(pool) { }
-    };
-
-    sp<IBinder::DeathRecipient> observer = new ProducerDeathObserver(*const_cast<GuiExtPool*>(this));
-    token->linkToDeath(observer);
-
-    sp<GuiExtPoolItem> item = new GuiExtPoolItem(token, isHwcNeeded, *poolId, w, h, mDisplayList, observer);
-    status_t err;
-    err = item->prepareBuffer(gralloc_usage);
-    if (err != NO_ERROR) {
-        GUIEXT_LOGE("  alloc fail, isHWcNeeded=%d, w=%d, h=%d, usage=%x, poolId=%d", isHwcNeeded, w, h, gralloc_usage, *poolId);
-        *poolId = 0;
-        return err;
-    }
-
-    mPoolList.add(*poolId, item);
-
-    const nsecs_t time_end = systemTime();
-    GUIEXT_LOGI("  alloc cost time=%" PRId64 " ms, gralloc_usage=%x, w=%d, h=%d, poolId=%d", ns2ms(time_end - time_start),
-        gralloc_usage, w, h, *poolId);
-
-    return err;
-}
-
-status_t GuiExtPool::free(uint32_t poolId)
-{
-    Mutex::Autolock _l(mLock);
-    ATRACE_CALL();
-    GUIEXT_LOGD("  free, poolId=%d", poolId);
-
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(poolId);
-    if (item == NULL) {
-        GUIEXT_LOGE("free a non-exist pool item, poolId=%d", poolId);
-        return BAD_INDEX;
-    }
-
-    item->mProducerToken = NULL;
-    item->mProducerPid = -1;
-    removePoolItemLocked(poolId);
-    return NO_ERROR;
-}
-
-status_t GuiExtPool::acquire(const sp<IBinder>& token, uint32_t poolId, uint32_t usage, uint32_t type, int *buf)
-{
-    Mutex::Autolock _l(mLock);
-    ATRACE_CALL();
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(poolId);
-    if (item == NULL) {
-        *buf = -1;
-        GUIEXT_LOGW("  acquire fail (pool not found), poolId=%d, usage=%s, type=%s, buf=%d", poolId, szUsageName[usage], szDisplayType[type], *buf);
-        return BAD_INDEX;
-    }
-
-    class BinderDiedListenerImpl : public BinderDiedListener {
-        GuiExtPool & mPool;
-        virtual void binderDied(uint32_t poolId) {
-            GUIEXT_LOGV("  [cb] all consumers has disconnected +, poolId=%d", poolId);
-            mPool.removePoolItem(poolId);
-            GUIEXT_LOGV("  [cb] consumer has died -");
-        }
-    public:
-        BinderDiedListenerImpl(GuiExtPool & pool) : mPool(pool) { }
-    };
-
-    sp<BinderDiedListener> listener = new BinderDiedListenerImpl(*const_cast<GuiExtPool*>(this));
-
-    status_t err = item->acquire(token, usage, type, listener, buf);
-    GUIEXT_LOGD("  acquire done, token=%p, poolId=%d, usage=%s, type=%s, buf=%d", token.get(), poolId, szUsageName[usage], szDisplayType[type], *buf);
-    return err;
-}
-
-status_t GuiExtPool::request(uint32_t poolId, uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer)
-{
-    Mutex::Autolock _l(mLock);
-    ATRACE_CALL();
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(poolId);
-    if (item == NULL) {
-        GUIEXT_LOGW("  request fail (pool not found), poolId=%d, usage=%s, type=%s", poolId, szUsageName[usage], szDisplayType[type]);
-        return BAD_INDEX;
-    }
-    status_t err = item->request(usage, type, buf, buffer);
-    GUIEXT_LOGD("  request done, poolId=%d, usage=%s, type=%s, buf=%d, buffer=%p", poolId, szUsageName[usage], szDisplayType[type], buf, (*buffer).get());
-    return err;
-}
-
-status_t GuiExtPool::release(uint32_t poolId, uint32_t usage, uint32_t type, int buf)
-{
-    Mutex::Autolock _l(mLock);
-    ATRACE_CALL();
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(poolId);
-    if (item == NULL) {
-        GUIEXT_LOGW("  release fail (pool not found), poolId=%d, usage=%s, type=%s", poolId, szUsageName[usage], szDisplayType[type]);
-        return BAD_INDEX;
-    }
-    status_t err = item->release(usage, type, buf);
-    GUIEXT_LOGD("  release done, poolId=%d, usage=%s, type=%s, buf=%d", poolId, szUsageName[usage], szDisplayType[type], buf);
-    return err;
-}
-
-status_t GuiExtPool::disconnect(uint32_t poolId, uint32_t usage, uint32_t type)
-{
-    Mutex::Autolock _l(mLock);
-    ATRACE_CALL();
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(poolId);
-    if (item == NULL) {
-        GUIEXT_LOGW("  disconnect fail (pool not found), poolId=%d, usage=%s, type=%s", poolId, szUsageName[usage], szDisplayType[type]);
-        return BAD_INDEX;
-    }
-    status_t err = item->disconnect(usage, type);
-    removePoolItemLocked(poolId);
-    GUIEXT_LOGD("  disconnect done, poolId=%d, usage=%s, type=%s", poolId, szUsageName[usage], szDisplayType[type]);
-    return err;
-}
-
-void GuiExtPool::configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum)
-{
-    GUIEXT_LOGD("  configDisplay, type=%d, enable=%d, w=%d, h=%d, bufNum=%d", type, enable, w, h, bufNum);
-    if (type == HWC_DISPLAY_PRIMARY)
-        GUIEXT_LOGI("  configDisplay, try to modify primary display, type=%d, w=%d, h=%d, bufNum=%d", type, w, h, bufNum);
-
-    sp<DispInfo> disp = mDisplayList.valueFor(type);
-
-    if (!enable || !w || !h || !bufNum) {
-        if (disp != 0) {
-            if (type != HWC_DISPLAY_PRIMARY) {
-                GUIEXT_LOGI("  configDisplay, remove type=%d, w=%d, h=%d, bufNum=%d", type, w, h, bufNum);
-                mDisplayList.removeItem(type);
-            }
-
-            GUIEXT_LOGI("  configDisplay, remove type=%d, enable=%d, w=%d, h=%d, bufNum=%d", type, enable, w, h, bufNum);
-            mDisplayList.removeItem(type);
-        }
-    } else {
-        if (disp == 0) {
-            disp = new DispInfo();
-            GUIEXT_LOGI("  configDisplay, add new type=%d, w=%d, h=%d, bufNum=%d", type, w, h, bufNum);
-        } else {
-            GUIEXT_LOGI("  configDisplay, change config of type=%d, w=%d, h=%d, bufNum=%d", type, w, h, bufNum);
-        }
-
-        disp->type = type;
-        disp->w = w;
-        disp->h = h;
-        disp->bufNum = bufNum;
-        mDisplayList.add(type, disp);
-    }
-
-    if (mDisplayList.size() == 0)
-        GUIEXT_LOGW("  configDisplay, all display config has been removed, type=%d, enable=%d", type, enable);
-}
-
-void GuiExtPool::removePoolItemLocked(uint32_t poolId)
-{
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(poolId);
-    if (item == NULL) {
-        GUIEXT_LOGW("  remove a non-exist pool item, poolId=%d", poolId);
-        return;
-    }
-
-    bool hasConsumerExist = false;
-    for (uint32_t i = 0; i < GUI_EXT_USAGE_MAX; i++) {
-        if (!item->mIsDisconnected[i]) {
-            hasConsumerExist = true;
-            GUIEXT_LOGV(" find poolId=%d exist consumer[%s]", poolId, szUsageName[i]);
-            return;
-        }
-    }
-
-    if (!hasConsumerExist && item->mProducerToken == NULL) {
-        mPoolList.removeItem(poolId);
-        GUIEXT_LOGV("remove pool item, id=%d", poolId);
-    } else {
-        GUIEXT_LOGV("remove pool item fail, id=%d, producer not free yet, token=%p, pid=%d",
-            poolId, item->mProducerToken.get(), item->mProducerPid);
-    }
-}
-
-void GuiExtPool::removePoolItem(uint32_t poolId)
-{
-    Mutex::Autolock _l(mLock);
-    removePoolItemLocked(poolId);
-}
-
-void GuiExtPool::dump(String8& result) const
-{
-    uint32_t size = mPoolList.size();
-    uint32_t disp_num = mDisplayList.size();
-
-    result.appendFormat("Display Num: %d\n", disp_num);
-    result.append("--------------------------------------------------\n");
-    for (uint32_t i = 0; i < disp_num; i++) {
-        const sp<DispInfo>& disp = mDisplayList[i];
-        result.appendFormat("+ DispInfo[%d]\n", i);
-        result.appendFormat("    type=%s, w=%d, h=%d, bufNum=%d\n",
-            szDisplayType[disp->type], disp->w, disp->h, disp->bufNum);
-    }
-    result.append("--------------------------------------------------\n");
-
-    result.appendFormat("\nPool List Size: %d\n", size);
-    result.append("--------------------------------------------------\n");
-    for (uint32_t i = 0; i < size; i ++) {
-        result.appendFormat("+ Pool[%d]\n", i);
-        mPoolList[i]->dump(result);
-    }
-    result.append("--------------------------------------------------\n");
-}
-
-uint32_t GuiExtPool::getPoolId()
-{
-    mPoolId = (mPoolId+1)%MAX_ALLOC_SIZE;
-    uint32_t id = mPoolId == 0 ? MAX_ALLOC_SIZE : mPoolId;
-    sp<GuiExtPoolItem> item = mPoolList.valueFor(id);
-    while (item != NULL) {
-        mPoolId = (mPoolId+1)%MAX_ALLOC_SIZE;
-        id = mPoolId == 0 ? MAX_ALLOC_SIZE : mPoolId;
-        item = mPoolList.valueFor(id);
-    }
-
-    mPoolId = id;
-
-    return id;
-}
-
-//------------------------------------------------------------------------------
-
-GuiExtPoolItem::GuiExtPoolItem(const sp<IBinder>& token,
-                bool isHwcNeeded,
-                uint32_t poolId,
-                uint32_t /*w*/,
-                uint32_t /*h*/,
-                DefaultKeyedVector< uint32_t, sp<DispInfo> >& dispList,
-                sp<IBinder::DeathRecipient> observer)
-                : mConsumerDeathListener(NULL)
-                //, mGPUUsedBq(NULL)
-                , mGPUUsedProducer(NULL)
-                , mGPUUsedConsumer(NULL)
-#if !SUPPORT_MULTIBQ_FOR_HWC
-                , mHwcUsedBq(NULL)
-#endif
-                , mId(poolId)
-                , mIsHwcNeeded(isHwcNeeded)
-                , mGpuUsedBufNum(MAX_GLES_DEQUEUED_NUM)
-                , mProducerPid(-1)
-                , mProducerToken(token)
-                , mProducerDeathObserver(observer)
-
-{
-    GUIEXT_LOGV("GuiExtPoolItem ctor, poolId=%d, isHwcNeeded=%d, token=%p", poolId, isHwcNeeded, token.get());
-
-    //String8 name(szUsageName[0]);
-    //name.appendFormat("_%d", poolId);
-    //mGPUUsedBq = createBufferQueue(w, h, mGpuUsedBufNum, name);
-    //createBufferQueue(w, h, mGpuUsedBufNum, name, &mGPUUsedProducer, &mGPUUsedConsumer);
-
-#ifdef CONFIG_FOR_SOURCE_PQ
-    if (DispDevice::getInstance().getPqNum() == 1)
-    {
-        DispDevice::getInstance().setOverlaySessionMode(DISP_SESSION_DECOUPLE_MODE);
-    }
-#endif
-    if (mIsHwcNeeded) {
-        String8 name(szUsageName[1]);
-        name.appendFormat("_%d", poolId);
-#if SUPPORT_MULTIBQ_FOR_HWC
-        uint32_t disp_size = dispList.size();
-        for (uint32_t i = 0; i < disp_size; i++) {
-            uint32_t type = dispList[i]->type;
-            String8 extname(name);
-            extname.appendFormat("_%d", type);
-            sp<HwcBqSlot> slot = new HwcBqSlot();
-            //slot->bq = createBufferQueue(dispList[i]->w, dispList[i]->h, dispList[i]->bufNum, extname);
-            createBufferQueue(dispList[i]->w, dispList[i]->h, dispList[i]->bufNum, extname, &slot->mProducer, &slot->mConsumer);
-            slot->type = type;
-            slot->bufNum = dispList[i]->bufNum;
-            mHwcUsedBqList.add(type, slot);
-        }
-#else
-        mHwcUsedBq = createBufferQueue(dispList[0]->w, dispList[0]->h, dispList[i]->bufNum, name);
-#endif
-    }
-
-    mProducerPid = (NULL != token->localBinder())
-                 ? getpid()
-                 : IPCThreadState::self()->getCallingPid();
-
-    for (uint32_t i = 0; i < GUI_EXT_USAGE_MAX; i++)
-        mIsDisconnected[i] = true;
-}
-
-GuiExtPoolItem::~GuiExtPoolItem()
-{
-    //mGPUUsedBq.clear();
-    mGPUUsedProducer.clear();
-    mGPUUsedConsumer.clear();
-#if SUPPORT_MULTIBQ_FOR_HWC
-    mHwcUsedBqList.clear();
-#else
-    mHwcUsedBq.clear();
-#endif
-
-#ifdef CONFIG_FOR_SOURCE_PQ
-    if (DispDevice::getInstance().getPqNum() == 1)
-    {
-        DispDevice::getInstance().setOverlaySessionMode(DISP_SESSION_DIRECT_LINK_MODE);
-    }
-#endif
-}
-
-void GuiExtPoolItem::createBufferQueue(uint32_t w, uint32_t h, uint32_t num, String8 name,
-    sp<IGraphicBufferProducer>* p, sp<IGraphicBufferConsumer>* c)
-{
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-ALOGD("***createBufferQueue: w=%d,h=%d,name=%s",w,h,name.string());
-    consumer->setDefaultBufferSize(w, h);
-    consumer->setConsumerName(name);
-	producer->setMaxDequeuedBufferCount(num);//setBufferCount(num);
-	consumer->setMaxAcquiredBufferCount(2);
-
-    // consumer connect
-    wp<ConsumerListener> listener = static_cast<ConsumerListener*>(this);
-    sp<BufferQueue::ProxyConsumerListener> proxy = new BufferQueue::ProxyConsumerListener(listener);
-    status_t err = consumer->consumerConnect(proxy, true);
-    if (err != NO_ERROR) {
-        ALOGE("GuiExtPoolItem: error connecting to BufferQueue: %s (%d)",
-                strerror(-err), err);
-    }
-
-    // producer connect
-    //static sp<BBinder> sLife = new BBinder();
-    static sp<IProducerListener> plistener = new DummyProducerListener();
-    IGraphicBufferProducer::QueueBufferOutput output;
-    err = producer->connect(plistener, NATIVE_WINDOW_API_MEDIA, true, &output);
-
-    *p = producer;
-    *c = consumer;
-}
-
-status_t GuiExtPoolItem::prepareBuffer(uint32_t gralloc_usage)
-{
-    status_t err = NO_ERROR;
-
-    //err = prepareBuffer(mGPUUsedProducer, GUI_EXT_USAGE_GPU, 0, gralloc_usage, mGpuUsedBufNum);
-    //GUIEXT_LOGV("    prepare %s buffer done", szUsageName[GUI_EXT_USAGE_GPU]);
-
-    if (mIsHwcNeeded) {
-#if SUPPORT_MULTIBQ_FOR_HWC
-        for (uint32_t i = 0; i < mHwcUsedBqList.size(); i++) {
-            err = prepareBuffer(mHwcUsedBqList[i]->mProducer, GUI_EXT_USAGE_HWC, mHwcUsedBqList[i]->type, gralloc_usage, mHwcUsedBqList[i]->bufNum);
-            GUIEXT_LOGV("    prepare %s buffer, type=%d done", szUsageName[GUI_EXT_USAGE_HWC], mHwcUsedBqList[i]->type);
-        }
-#else
-        err = prepareBuffer(mHwcUsedBq, GUI_EXT_USAGE_HWC, 0, gralloc_usage, mHwcUsedBqList[i]->bufNum);
-        GUIEXT_LOGV("    prepare %s buffer done", szUsageName[GUI_EXT_USAGE_HWC]);
-#endif
-    }
-
-    return err;
-}
-
-status_t GuiExtPoolItem::prepareBuffer(sp<IGraphicBufferProducer> producer, uint32_t usage, uint32_t type, uint32_t gralloc_usage, uint32_t bufNum)
-{
-    status_t err = NO_ERROR;
-    uint32_t usg = (gralloc_usage & GRALLOC_USAGE_SECURE) != 0 ? (LOCK_FOR_USAGE | GRALLOC_USAGE_SECURE) : LOCK_FOR_USAGE;
-    uint32_t fmt = gAcquiredFormat[usage];
-
-    GUIEXT_LOGV("prepareBuffer, type=%d, fmt=%x, usage=%x, usg=%x, bufNum=%d", usage, fmt, gralloc_usage, usg, bufNum);
-
-    for (uint32_t i = 0; i < bufNum; i++) {
-        int buf = -1;
-        sp<Fence> fence;
-
-        producer->dequeueBuffer(&buf, &fence, /*false,*/ 0, 0, fmt, usg);
-
-        uint32_t combine_id = POOL_COMBINED_ID(usage, type, i);
-        sp<ConsumerSlot> consumerSlot = mConsumerList.valueFor(combine_id);
-        if (consumerSlot == 0) {
-            sp<ConsumerSlot> slot = new ConsumerSlot();
-            slot->token = NULL;
-            slot->pid = -1;
-            slot->usage = usage;
-            slot->type = type;
-            slot->idx = i;
-            mConsumerList.add(combine_id, slot);
-        }
-
-#ifdef TOUCH_ION_BUFFER
-        sp<GraphicBuffer> gb;
-        producer->requestBuffer(buf, &gb);
-        touchIonBuffer(gb);
-#endif
-    }
-
-    for (uint32_t i = 0; i < bufNum; i++) {
-        sp<Fence> fence = Fence::NO_FENCE;
-        producer->cancelBuffer(i, fence);
-    }
-
-    return err;
-}
-
-#ifdef TOUCH_ION_BUFFER
-buffer_handle_t GuiExtPoolItem::getNativehandle(android_native_buffer_t* buffer)
-{
-    if ((buffer->common.magic   == ANDROID_NATIVE_BUFFER_MAGIC) &&
-        (buffer->common.version == sizeof(android_native_buffer_t)))
-    {
-        return buffer->handle;
-    }
-    return 0;
-}
-
-void GuiExtPoolItem::touchIonBuffer(sp<GraphicBuffer> gb)
-{
-    int ion_fd = -1;
-    android_native_buffer_t* buffer = gb.get();
-    buffer_handle_t hnd = getNativehandle(buffer);
-    int err = 0;
-    uint32_t bufSize = 0;
-    GuiExtIONDevice &device(GuiExtIONDevice::getInstance());
-
-    err |= gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_FD, &ion_fd);
-
-    uint32_t ion_hnd = device.import(ion_fd);
-    device.touchMMUAddress(0, ion_hnd);
-    close(ion_hnd);
-}
-#endif
-
-status_t GuiExtPoolItem::acquire(const sp<IBinder>& token, uint32_t usage, uint32_t type, sp<BinderDiedListener> listener, int *buf)
-{
-    if (!mIsHwcNeeded && usage == GUI_EXT_USAGE_HWC) {
-        GUIEXT_LOGW("    acquire a pool=%d not alloc hwc usage buffer", mId);
-        return INVALID_OPERATION;
-    }
-
-    sp<IGraphicBufferProducer> producer = getIGraphicBufferProducer(usage, type);
-    if (producer == NULL) {
-        GUIEXT_LOGW("    acquire a pool=%d not alloc hwc usage buffer, type=%d", mId, type);
-        return BAD_INDEX;
-    }
-    sp<Fence> fence;
-    uint32_t fmt = gAcquiredFormat[usage];
-    status_t ret = producer->dequeueBuffer(buf, &fence, /*false,*/ 0, 0, fmt, LOCK_FOR_USAGE);
-    if (ret == WOULD_BLOCK || *buf < 0) {
-        GUIEXT_LOGW("    acquire a pool=%d has no free slot", mId);
-        return WOULD_BLOCK;
-    }
-
-    class ConsumerDeathObserver : public IBinder::DeathRecipient {
-        GuiExtPoolItem & mItem;
-        virtual void binderDied(const wp<IBinder>& who) {
-            uint32_t size = mItem.mConsumerList.size();
-            GUIEXT_LOGI("consumer died, list size=%d, binder ptr=[%p]", size, who.unsafe_get());
-
-            if (size == 0) {
-                GUIEXT_LOGV("consumer died [%p], pool size is zero", who.unsafe_get());
-            } else {
-                for (uint32_t i = 0 ; i < size ; i++) {
-                    GUIEXT_LOGV("   [c] compare index[%d], p=[%p], usage=%d, type=%d, id=%d", i,
-                        mItem.mConsumerList[i]->token.get(),
-                        mItem.mConsumerList[i]->usage, mItem.mConsumerList[i]->type, mItem.mConsumerList[i]->idx);
-                    if (mItem.mConsumerList[i]->token.get() == who.unsafe_get()) {
-                        GUIEXT_LOGW("   [c] found index[%d], p=[%p], usage=%d, type=%d, id=%d", i,
-                            mItem.mConsumerList[i]->token.get(),
-                            mItem.mConsumerList[i]->usage, mItem.mConsumerList[i]->type, mItem.mConsumerList[i]->idx);
-
-                        mItem.release(mItem.mConsumerList[i]->usage, mItem.mConsumerList[i]->type, mItem.mConsumerList[i]->idx);
-                        mItem.mConsumerList[i]->token = NULL;
-                        mItem.mConsumerList[i]->pid = -1;
-                        mItem.mConsumerList[i]->observer = NULL;
-                    }
-                }
-
-                for (uint32_t i = 0; i < GUI_EXT_USAGE_MAX; i++) {
-                    mItem.mIsDisconnected[i] = true;
-                }
-                bool isDisconnect = true;
-                for (uint32_t i = 0 ; i < size ; i++) {
-                    if (mItem.mConsumerList[i]->token != NULL) {
-                        mItem.mIsDisconnected[mItem.mConsumerList[i]->usage] = false;
-                        isDisconnect = false;
-                        GUIEXT_LOGV("   [c] still have consumer, idx=%d, token=%p, pid=%d, usage=%d, type=%d, id=%d", i,
-                            mItem.mConsumerList[i]->token.get(), mItem.mConsumerList[i]->pid,
-                            mItem.mConsumerList[i]->usage, mItem.mConsumerList[i]->type, mItem.mConsumerList[i]->idx);
-                    }
-                }
-
-                if (isDisconnect) {
-                    mItem.mConsumerDeathListener->binderDied(mItem.mId);
-                }
-
-                GUIEXT_LOGV("consumer died done");
-            }
-        }
-    public:
-        ConsumerDeathObserver(GuiExtPoolItem & item) : mItem(item) { }
-    };
-
-    sp<IBinder::DeathRecipient> observer = new ConsumerDeathObserver(*const_cast<GuiExtPoolItem*>(this));
-    token->linkToDeath(observer);
-
-    uint32_t combine_id = POOL_COMBINED_ID(usage, type, *buf);
-    sp<ConsumerSlot> consumerSlot = mConsumerList.valueFor(combine_id);
-    if (consumerSlot == NULL) {
-        GUIEXT_LOGW("    acquire a pool=%d not pre-alloc consumer slot", mId);
-        return BAD_INDEX;
-    }
-
-    if (consumerSlot->token == NULL) {
-        sp<ConsumerSlot> slot = new ConsumerSlot();
-        slot->token = token;
-        slot->usage = usage;
-        slot->type = type;
-        slot->idx = *buf;
-        slot->pid = (NULL != token->localBinder())
-                 ? getpid()
-                 : IPCThreadState::self()->getCallingPid();
-        slot->observer = observer;
-        mConsumerList.add(combine_id, slot);
-    }
-
-    mIsDisconnected[usage] = false;
-    mConsumerDeathListener = listener;
-
-    return NO_ERROR;
-}
-
-status_t GuiExtPoolItem::request(uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer)
-{
-    if (!mIsHwcNeeded && usage == GUI_EXT_USAGE_HWC) {
-        GUIEXT_LOGW("    request a pool=%d not alloc hwc usage buffer", mId);
-        return INVALID_OPERATION;
-    }
-    // To-Do: support multiple hwc bq
-    sp<IGraphicBufferProducer> producer = getIGraphicBufferProducer(usage, type);
-    if (producer == NULL) {
-        GUIEXT_LOGW("    request a pool=%d not alloc hwc usage buffer, type=%d", mId, type);
-        return BAD_INDEX;
-    }
-    producer->requestBuffer(buf, buffer);
-
-    return NO_ERROR;
-}
-
-status_t GuiExtPoolItem::release(uint32_t usage, uint32_t type, int buf)
-{
-    if (!mIsHwcNeeded && usage == GUI_EXT_USAGE_HWC) {
-        GUIEXT_LOGW("    release a pool=%d not alloc hwc usage buffer", mId);
-        return INVALID_OPERATION;
-    }
-    // To-Do: support multiple hwc bq
-    sp<IGraphicBufferProducer> producer = getIGraphicBufferProducer(usage, type);
-    if (producer == NULL) {
-        GUIEXT_LOGW("    release a pool=%d not alloc hwc usage buffer, type=%d", mId, type);
-        return BAD_INDEX;
-    }
-    sp<Fence> fence = Fence::NO_FENCE;
-    producer->cancelBuffer(buf, fence);
-
-    uint32_t combine_id = POOL_COMBINED_ID(usage, type, buf);
-    sp<ConsumerSlot> consumerSlot = mConsumerList.valueFor(combine_id);
-    if (consumerSlot != 0) {
-        consumerSlot->token = NULL;
-        consumerSlot->pid = -1;
-        consumerSlot->observer = NULL;
-        mConsumerList.add(combine_id, consumerSlot);
-    }
-
-    return NO_ERROR;
-}
-
-sp<IGraphicBufferProducer> GuiExtPoolItem::getIGraphicBufferProducer(uint32_t usage, uint32_t type)
-{
-    sp<IGraphicBufferProducer> producer = mGPUUsedProducer;
-    if (usage == GUI_EXT_USAGE_HWC) {
-#if SUPPORT_MULTIBQ_FOR_HWC
-        sp<HwcBqSlot> slot = mHwcUsedBqList.valueFor(type);
-        if (type >= HWC_NUM_DISPLAY_TYPES || slot == NULL) {
-            GUIEXT_LOGE("    try to get HWC BufferQueue not has hwc display type=%d buffer\n", type);
-            return NULL;
-        }
-        producer = slot->mProducer;
-#else
-        bq = mHwcUsedBq;
-#endif
-    }
-
-    return producer;
-}
-
-status_t GuiExtPoolItem::disconnect(uint32_t usage, uint32_t /*type*/)
-{
-    if (!mIsHwcNeeded && usage == GUI_EXT_USAGE_HWC) {
-        GUIEXT_LOGW("    release a pool=%d not alloc hwc usage buffer", mId);
-        return INVALID_OPERATION;
-    }
-
-    mIsDisconnected[usage] = true;
-    return NO_ERROR;
-}
-
-void GuiExtPoolItem::dump(String8& result) const
-{
-    int w, h;
-    result.appendFormat("    "
-                        "this=%p mId=%d, mIsHwcNeeded=%d, mProducerPid=%d, mProducerToken=%p\n",
-                        this, mId, mIsHwcNeeded, mProducerPid, mProducerToken.get());
-
-    if(mGPUUsedConsumer != NULL){
-        result.appendFormat("    << GPU BQ >>\n");
-        mGPUUsedConsumer->dumpState(result, "        ");//dump(result, "        ");
-
-        result.appendFormat("    << GPU Consumer >> connected=%s\n",
-                        mIsDisconnected[GUI_EXT_USAGE_GPU] ? "false" : "true");
-        dumpConsumerSlots(result, GUI_EXT_USAGE_GPU, 0);
-    }else{
-        result.appendFormat("    << GPU BQ isn't generated  >>\n");
-    }
-
-    if (mIsHwcNeeded) {
-#if SUPPORT_MULTIBQ_FOR_HWC
-        for (uint32_t i = 0; i < mHwcUsedBqList.size(); i++) {
-            result.appendFormat("    << HWC BQ >> type=%d\n", mHwcUsedBqList[i]->type);
-            mHwcUsedBqList[i]->mConsumer->dumpState(result, "        ");//dump(result, "        ");
-
-            result.appendFormat("    << HWC Consumer >> type=%d connected=%s\n",
-                                mHwcUsedBqList[i]->type,
-                                mIsDisconnected[GUI_EXT_USAGE_HWC] ? "false" : "true");
-            dumpConsumerSlots(result, GUI_EXT_USAGE_HWC, mHwcUsedBqList[i]->type);
-        }
-#else
-        result.appendFormat("    << HWC BQ >>\n");
-        mHwcUsedBq->dumpState(result, "        ");//dump(result, "        ");
-
-        result.appendFormat("    << HWC Consumer >> connected=%s\n",
-                            mIsDisconnected[GUI_EXT_USAGE_HWC] ? "false" : "true");
-        dumpConsumerSlots(result, GUI_EXT_USAGE_HWC, 0);
-#endif
-    }
-}
-
-void GuiExtPoolItem::dumpConsumerSlots(String8 & result, uint32_t usage, uint32_t type) const
-{
-    uint32_t list_size = mConsumerList.size();
-    if (list_size > 0) {
-        for (uint32_t i = 0; i < list_size; i++) {
-            uint32_t combine_id = POOL_COMBINED_ID(usage, type, i);
-            sp<ConsumerSlot> consumerSlot = mConsumerList.valueFor(combine_id);
-            if (consumerSlot != 0) {
-                result.append("        ");
-                consumerSlot->dump(result);
-            } else break;
-        }
-    }
-}
-
-void GuiExtPoolItem::ConsumerSlot::dump(String8& result) const
-{
-    result.appendFormat("[%02d] pid=%d, token=%p, observer=%p\n", idx, pid, token.get(), observer.get());
-}
-
-// ---------------------------------------------------------------------------
-
-#ifdef TOUCH_ION_BUFFER
-ANDROID_SINGLETON_STATIC_INSTANCE(GuiExtIONDevice);
-
-GuiExtIONDevice::GuiExtIONDevice()
-{
-    m_dev_fd = open(ION_DEV_NODE, O_RDONLY);
-    if (m_dev_fd <= 0)
-    {
-        GUIEXT_LOGE("Failed to open ION device: %s ", strerror(errno));
-    }
-}
-
-GuiExtIONDevice::~GuiExtIONDevice()
-{
-    if (m_dev_fd > 0) close(m_dev_fd);
-}
-
-uint32_t GuiExtIONDevice::import(int ion_fd)
-{
-    if (m_dev_fd <= 0) return 0;
-
-    struct ion_handle* ion_hnd;
-    if (ion_import(m_dev_fd, ion_fd, &ion_hnd))
-    {
-        GUIEXT_LOGE("Failed to import ION handle: %s ", strerror(errno));
-        return 0;
-    }
-
-    return (unsigned int)ion_hnd;
-}
-
-void GuiExtIONDevice::touchMMUAddress(int client, int ion_hnd)
-{
-    if (m_dev_fd <= 0) return;
-
-    // configure before querying physical address
-    struct ion_mm_data mm_data;
-    mm_data.mm_cmd                        = ION_MM_CONFIG_BUFFER;
-    mm_data.config_buffer_param.handle    = (struct ion_handle *) ion_hnd;
-    mm_data.config_buffer_param.eModuleID = client;
-    mm_data.config_buffer_param.security  = 0;
-    mm_data.config_buffer_param.coherent  = 0;
-
-    int status = ion_custom_ioctl(m_dev_fd, ION_CMD_MULTIMEDIA, &mm_data);
-    if ((status > 0) && (status != ION_ERROR_CONFIG_LOCKED))
-    {
-        GUIEXT_LOGE("Failed to config ION memory: %s", strerror(errno));
-        return;
-    }
-
-    // get physical address
-    struct ion_sys_data sys_data;
-    sys_data.sys_cmd               = ION_SYS_GET_PHYS;
-    sys_data.get_phys_param.handle = (struct ion_handle *) ion_hnd;
-    if (ion_custom_ioctl(m_dev_fd, ION_CMD_SYSTEM, &sys_data))
-    {
-        GUIEXT_LOGE("Failed to get MVA from ION: %s", strerror(errno));
-        return;
-    }
-}
-#endif
-
-}
diff --git a/gui_ext/lib/GuiExtImpl.h b/gui_ext/lib/GuiExtImpl.h
deleted file mode 100755
index 3a15245..0000000
--- a/gui_ext/lib/GuiExtImpl.h
+++ /dev/null
@@ -1,173 +0,0 @@
-#ifndef __GUIEXT_IMPL_H__
-#define __GUIEXT_IMPL_H__
-
-#include <utils/KeyedVector.h>
-#include <utils/RefBase.h>
-#include "GuiExtDataType.h"
-
-namespace android {
-
-class IBinder;
-class BufferQueue;
-class GraphicBuffer;
-class GuiExtPoolItem;
-
-#define SUPPORT_MULTIBQ_FOR_HWC 1
-//#define SUPPORT_MULTIBQ_FOR_HWC 0
-//#define TOUCH_ION_BUFFER
-
-class BinderDiedListener : public virtual RefBase {
-public:
-    BinderDiedListener() { }
-    virtual ~BinderDiedListener() { }
-
-    virtual void binderDied(uint32_t poolId) = 0; /* Asynchronous */
-};
-//------------------------------------------------------------------------------
-
-class DispInfo : public virtual RefBase {
-    public:
-        uint32_t type;
-        uint32_t w;
-        uint32_t h;
-        uint32_t bufNum;
-};
-//------------------------------------------------------------------------------
-
-// GuiExtPool class
-class GuiExtPool : public virtual RefBase {
-public:
-    GuiExtPool();
-    ~GuiExtPool();
-
-    status_t alloc(const sp<IBinder>& token, uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *poolId);
-    status_t free(uint32_t poolId);
-    status_t acquire(const sp<IBinder>& token, uint32_t poolId, uint32_t usage, uint32_t type, int *buf);
-    status_t request(uint32_t poolId, uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer);
-    status_t release(uint32_t poolId, uint32_t usage, uint32_t type, int buf);
-    status_t disconnect(uint32_t poolId, uint32_t usage, uint32_t type);
-    void configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum);
-
-    void removePoolItemLocked(uint32_t poolId);
-    void removePoolItem(uint32_t poolId);
-    void dump(String8& result) const;
-
-private:
-    uint32_t mPoolId;
-    DefaultKeyedVector< uint32_t, sp<GuiExtPoolItem> > mPoolList;
-    DefaultKeyedVector< uint32_t, sp<DispInfo> > mDisplayList;
-
-    mutable Mutex mLock;
-    mutable sp<BinderDiedListener> mConsumerDeathObserver;
-
-    uint32_t mDefaultDisplayWidth;
-    uint32_t mDefaultDisplayHeight;
-
-    uint32_t getPoolId();
-};
-
-//------------------------------------------------------------------------------
-
-// GuiExtPoolItem class
-class GuiExtPoolItem : public virtual RefBase,
-                       protected ConsumerListener {
-public:
-    GuiExtPoolItem(const sp<IBinder>& token,
-                   bool isHwcNeeded,
-                   uint32_t id,
-                   uint32_t w,
-                   uint32_t h,
-                   DefaultKeyedVector< uint32_t, sp<DispInfo> >& dispList,
-                   sp<IBinder::DeathRecipient> observer);
-    ~GuiExtPoolItem();
-
-    status_t prepareBuffer(uint32_t usage);
-    status_t acquire(const sp<IBinder>& token, uint32_t usage, uint32_t type, sp<BinderDiedListener> listener, int *buf);
-    status_t request(uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer);
-    status_t release(uint32_t usage, uint32_t type, int buf);
-    status_t disconnect(uint32_t usage, uint32_t type);
-
-    virtual void onFrameAvailable(const BufferItem& item) {};
-    virtual void onBuffersReleased() {};
-    virtual void onSidebandStreamChanged() {};
-
-    sp<BinderDiedListener> mConsumerDeathListener;
-
-private:
-    friend class GuiExtPool;
-
-    //sp<BufferQueue> mGPUUsedBq;
-    sp<IGraphicBufferProducer> mGPUUsedProducer;
-    sp<IGraphicBufferConsumer> mGPUUsedConsumer;
-#if SUPPORT_MULTIBQ_FOR_HWC
-    class HwcBqSlot : public virtual RefBase {
-        public:
-            //sp<BufferQueue> bq;
-            sp<IGraphicBufferProducer> mProducer;
-            sp<IGraphicBufferConsumer> mConsumer;
-            uint32_t type;
-            uint32_t bufNum;
-    };
-    DefaultKeyedVector< uint32_t, sp<HwcBqSlot> > mHwcUsedBqList;
-#else
-    sp<BufferQueue> mHwcUsedBq;
-#endif
-
-    uint32_t mId;
-    uint32_t mIsHwcNeeded;
-    uint32_t mGpuUsedBufNum;
-    int32_t  mProducerPid;
-    bool mIsDisconnected[GUI_EXT_USAGE_MAX];
-
-    sp<IBinder> mProducerToken;
-
-    class ConsumerSlot : public virtual RefBase {
-        public:
-            uint32_t usage;
-            uint32_t type;
-            uint32_t idx;
-            int pid;
-            sp<IBinder> token;
-            mutable sp<IBinder::DeathRecipient> observer;
-
-            void dump(String8& result) const;
-    };
-    DefaultKeyedVector< uint32_t, sp<ConsumerSlot> > mConsumerList;
-
-    mutable sp<IBinder::DeathRecipient> mProducerDeathObserver;
-
-    void createBufferQueue(uint32_t w, uint32_t h, uint32_t num, String8 name,
-        sp<IGraphicBufferProducer>* p, sp<IGraphicBufferConsumer>* c);
-//    sp<BufferQueue> getBufferQueue(uint32_t usage, uint32_t type);
-    sp<IGraphicBufferProducer> getIGraphicBufferProducer(uint32_t usage, uint32_t type);
-
-    status_t prepareBuffer(sp<IGraphicBufferProducer> producer, uint32_t usage, uint32_t type, uint32_t gralloc_usage, uint32_t bufNum);
-#ifdef TOUCH_ION_BUFFER
-    void touchIonBuffer(sp<GraphicBuffer> gb);
-    buffer_handle_t getNativehandle(android_native_buffer_t* buffer);
-#endif
-
-    void dump(String8& result) const;
-    void dumpConsumerSlots(String8& result, uint32_t usage, uint32_t type) const;
-};
-
-//------------------------------------------------------------------------------
-
-#ifdef TOUCH_ION_BUFFER
-class GuiExtIONDevice : public Singleton<GuiExtIONDevice>
-{
-public:
-    GuiExtIONDevice();
-    ~GuiExtIONDevice();
-
-    // import handle from ion share fd
-    uint32_t import(int ion_fd);
-    void touchMMUAddress(int client, int ion_hnd);
-
-private:
-    int m_dev_fd;
-};
-#endif
-}
-#endif
-
diff --git a/gui_ext/lib/GuiExtService.cpp b/gui_ext/lib/GuiExtService.cpp
deleted file mode 100755
index 68b147b..0000000
--- a/gui_ext/lib/GuiExtService.cpp
+++ /dev/null
@@ -1,281 +0,0 @@
-#define LOG_TAG "GuiExt"
-
-#define MTK_LOG_ENABLE 1
-#include <dlfcn.h>
-#include <fcntl.h>
-#include <math.h>
-#include <string.h>
-#include <cutils/log.h>
-#include <cutils/properties.h>
-#include <utils/SortedVector.h>
-#include <binder/PermissionCache.h>
-
-#include <android/native_window.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/SurfaceComposerClient.h>
-
-#include <ui/DisplayInfo.h>
-#include <IDumpTunnel.h>
-
-#include <cutils/memory.h>
-
-#include "GuiExtService.h"
-#include "GuiExtImpl.h"
-
-namespace android {
-
-#define GUIEXT_LOGV(x, ...) ALOGV("[GuiExtS] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGD(x, ...) ALOGD("[GuiExtS] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGI(x, ...) ALOGI("[GuiExtS] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGW(x, ...) ALOGW("[GuiExtS] " x, ##__VA_ARGS__)
-#define GUIEXT_LOGE(x, ...) ALOGE("[GuiExtS] " x, ##__VA_ARGS__)
-
-GuiExtService::GuiExtService()
-{
-    GUIEXT_LOGI("GuiExtService ctor");
-    mPool = new GuiExtPool();
-}
-
-GuiExtService::~GuiExtService()
-{
-}
-
-status_t GuiExtService::alloc(const sp<IBinder>& token, uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *poolId)
-{
-    GUIEXT_LOGV("alloc, gralloc_usage=%x, w=%d, h=%d", gralloc_usage, w, h);
-    status_t ret = mPool->alloc(token, gralloc_usage, w, h, poolId);
-    return ret;
-}
-
-status_t GuiExtService::free(uint32_t poolId)
-{
-    GUIEXT_LOGV("free, poolId=%d", poolId);
-    status_t ret = mPool->free(poolId);
-    return ret;
-}
-
-status_t GuiExtService::acquire(const sp<IBinder>& token, uint32_t poolId, uint32_t usage, uint32_t type, int *buf)
-{
-    GUIEXT_LOGV("acquire, poolId=%d, usage=%x, type=%d", poolId, usage, type);
-    status_t ret = mPool->acquire(token, poolId, usage, type, buf);
-    return ret;
-}
-
-status_t GuiExtService::request(uint32_t poolId, uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer)
-{
-    GUIEXT_LOGV("request, poolId=%d, usage=%x, type=%d, buf=%d", poolId, usage, type, buf);
-    status_t ret = mPool->request(poolId, usage, type, buf, buffer);
-    return ret;
-}
-
-status_t GuiExtService::release(uint32_t poolId, uint32_t usage, uint32_t type, int buf)
-{
-    GUIEXT_LOGV("release, poolId=%d, usage=%x, buf=%d, type=%d", poolId, usage, buf, type);
-    status_t ret = mPool->release(poolId, usage, type, buf);
-    return ret;
-}
-
-status_t GuiExtService::disconnect(uint32_t poolId, uint32_t usage, uint32_t type)
-{
-    GUIEXT_LOGV("disconnect, poolId=%d, usage=%x, type=%d", poolId, usage, type);
-    status_t ret = mPool->disconnect(poolId, usage, type);
-    return ret;
-}
-
-status_t GuiExtService::configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum)
-{
-    GUIEXT_LOGV("configDisplay, type=%d, enable=%d, w=%d, h=%d, bufNum=%d", type, enable, w, h, bufNum);
-    mPool->configDisplay(type, enable, w, h, bufNum);
-    return NO_ERROR;
-}
-
-static const String16 sDump("android.permission.DUMP");
-status_t GuiExtService::dump(int fd, const Vector<String16>& /*args*/)
-{
-    String8 result;
-
-    if (!PermissionCache::checkCallingPermission(sDump)) {
-        result.appendFormat(
-                "Permission Denial: can't dump SurfaceFlinger from pid=%d, uid=%d\n",
-                IPCThreadState::self()->getCallingPid(),
-                IPCThreadState::self()->getCallingUid());
-    } else {
-        // Try to get the main lock, but don't insist if we can't
-        // (this would indicate GuiExtService is stuck, but we want to be able to
-        // print something in dumpsys).
-        int retry = 3;
-        while ((mLock.tryLock() < 0) && (--retry >= 0)) {
-            usleep(1000000);
-        }
-        const bool locked(retry >= 0);
-        if (!locked) {
-            result.appendFormat(
-                    "GuiExtService appears to be unresponsive, dumping anyways (no locks held)\n");
-        }
-
-        result.appendFormat(
-                "GuiExtService[pid=%d] state:\n\n",
-                getpid());
-
-        // internal pools state
-        mPool->dump(result);
-
-        if (locked) {
-            mLock.unlock();
-        }
-
-        result.appendFormat(
-                "\n\nRegistered Tunnels state: (total %zu tunnels)\n",
-                mDumpTunnels.size());
-
-        // into groups, currently for BufferQueue, RefBase, others
-        KeyedVector<String8, sp<IDumpTunnel> > zombieTunnels;            // TODO: make it not happen !
-        KeyedVector<String8, sp<IDumpTunnel> > bufferQueueTunnels;
-        KeyedVector<String8, sp<IDumpTunnel> > refBaseTunnels;
-        KeyedVector<String8, sp<IDumpTunnel> > otherTunnels;
-        for (uint32_t i = 0; i < mDumpTunnels.size(); ++i) {
-            const String8& key = mDumpTunnels.keyAt(i);
-            const sp<IDumpTunnel>& tunnel = mDumpTunnels.valueAt(i);
-
-            if (!tunnel->asBinder(tunnel)->isBinderAlive()) {
-                zombieTunnels.add(key, tunnel);
-            } else if (key.find("BQ") == 0) {
-                bufferQueueTunnels.add(key, tunnel);
-            } else if (key.find("RB") == 0) {
-                refBaseTunnels.add(key, tunnel);
-            } else {
-                refBaseTunnels.add(key, tunnel);
-            }
-        }
-
-        result.appendFormat(
-                "\nZOMBIE: %zu\n"
-                "--------------------------------------------------\n",
-                zombieTunnels.size());
-        {
-            Mutex::Autolock l(mDumpLock);
-            for (uint32_t i = 0; i < zombieTunnels.size(); ++i) {
-                const String8& key = zombieTunnels.keyAt(i);
-                const sp<IDumpTunnel>& tunnel = zombieTunnels.valueAt(i);
-                result.appendFormat("+ %s\n", key.string());
-                tunnel->kickDump(result, "    ");
-            }
-        }
-        result.append("--------------------------------------------------\n");
-
-        result.appendFormat(
-                "\nBufferQueue: %zu\n"
-                "--------------------------------------------------\n",
-                bufferQueueTunnels.size());
-        {
-            Mutex::Autolock l(mDumpLock);
-            for (uint32_t i = 0; i < bufferQueueTunnels.size(); ++i) {
-                const String8& key = bufferQueueTunnels.keyAt(i);
-                const sp<IDumpTunnel>& tunnel = bufferQueueTunnels.valueAt(i);
-                result.appendFormat("+ %s\n", key.string());
-                tunnel->kickDump(result, "    ");
-            }
-        }
-        result.append("--------------------------------------------------\n");
-
-        result.appendFormat(
-                "\nRefBase: %zu\n"
-                "--------------------------------------------------\n",
-                refBaseTunnels.size());
-        {
-            Mutex::Autolock l(mDumpLock);
-            for (uint32_t i = 0; i < refBaseTunnels.size(); i++) {
-                const String8& key = refBaseTunnels.keyAt(i);
-                const sp<IDumpTunnel>& tunnel = refBaseTunnels.valueAt(i);
-                result.appendFormat("+ %s\n", key.string());
-                tunnel->kickDump(result, "    ");
-            }
-        }
-        result.append("--------------------------------------------------\n");
-
-        result.appendFormat(
-                "\nOthers: %zu\n"
-                "--------------------------------------------------\n",
-                otherTunnels.size());
-        {
-            Mutex::Autolock l(mDumpLock);
-            for (uint32_t i = 0; i < otherTunnels.size(); i++) {
-                const String8& key = otherTunnels.keyAt(i);
-                const sp<IDumpTunnel>& tunnel = otherTunnels.valueAt(i);
-                result.appendFormat("+ %s\n", key.string());
-                tunnel->kickDump(result, "    ");
-            }
-        }
-        result.append("--------------------------------------------------\n");
-    }
-    write(fd, result.string(), result.size());
-    return NO_ERROR;
-}
-
-status_t GuiExtService::regDump(const sp<IDumpTunnel>& tunnel, const String8& key)
-{
-    // check the tunnel does not come from GuiExtService
-    if (!tunnel->asBinder(tunnel)->remoteBinder())
-        return NO_ERROR;
-
-    if (!tunnel->asBinder(tunnel)->isBinderAlive())
-        return BAD_VALUE;
-
-    class DeathNotifier : public IBinder::DeathRecipient
-    {
-    private:
-        const String8 mKey;
-        const wp<GuiExtService> mService;
-    public:
-        DeathNotifier(const String8& key, const wp<GuiExtService>& service)
-            : mKey(key)
-            , mService(service)
-        {
-            // since DeathNotifier will not be kept by linkToDeath
-            // we have to extend its lifetime manually
-            extendObjectLifetime(OBJECT_LIFETIME_WEAK);
-        }
-
-        virtual void binderDied(const wp<IBinder>& /*who*/)
-        {
-            GUIEXT_LOGD("binder of dump tunnel(%s) died", mKey.string());
-
-            sp<GuiExtService> service = mService.promote();
-            if (service != NULL)
-                service->unregDump(mKey);
-        }
-    };
-    sp<IBinder::DeathRecipient> notifier = new DeathNotifier(key, this);
-    if (notifier != NULL)
-        tunnel->asBinder(tunnel)->linkToDeath(notifier);
-
-    Mutex::Autolock l(mDumpLock);
-
-    if (mDumpTunnels.size() > 200)
-    {
-        const int32_t before = mDumpTunnels.size();
-
-        // loop and remove zombie objects
-        for (int32_t i = (before - 1); i >= 0; i--)
-        {
-            const sp<IDumpTunnel>& t = mDumpTunnels[i];
-            if (!t->asBinder(t)->isBinderAlive())
-            {
-                mDumpTunnels.removeItemsAt(i);
-            }
-        }
-
-        GUIEXT_LOGI("mDumpTunnels checked (before=%d, after:%d", before, mDumpTunnels.size());
-    }
-
-    mDumpTunnels.add(key, tunnel);
-    return NO_ERROR;
-}
-
-status_t GuiExtService::unregDump(const String8& key)
-{
-    Mutex::Autolock l(mDumpLock);
-    mDumpTunnels.removeItem(key);
-    return NO_ERROR;
-}
-};
diff --git a/gui_ext/lib/IGuiExtService.cpp b/gui_ext/lib/IGuiExtService.cpp
deleted file mode 100755
index 50b006c..0000000
--- a/gui_ext/lib/IGuiExtService.cpp
+++ /dev/null
@@ -1,338 +0,0 @@
-#define LOG_TAG "GuiExt"
-
-#define MTK_LOG_ENABLE 1
-#include <utils/Errors.h>
-#include <utils/RefBase.h>
-#include <utils/Vector.h>
-#include <utils/Timers.h>
-#include <utils/String8.h>
-
-#include <binder/Parcel.h>
-#include <binder/IInterface.h>
-
-#include <cutils/log.h>
-
-#include <ui/GraphicBuffer.h>
-#include <IDumpTunnel.h>
-
-#include "IGuiExtService.h"
-
-namespace android {
-
-// client : proxy GuiEx class
-class BpGuiExtService : public BpInterface<IGuiExtService>
-{
-public:
-    BpGuiExtService(const sp<IBinder>& impl) : BpInterface<IGuiExtService>(impl)
-    {
-    }
-
-    virtual status_t alloc(const sp<IBinder>& token, uint32_t gralloc_usage, uint32_t w, uint32_t h, uint32_t *id)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeStrongBinder(token);
-        data.writeInt32(gralloc_usage);
-        data.writeInt32(w);
-        data.writeInt32(h);
-        status_t result = remote()->transact(GUI_EXT_ALLOC, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("alloc could not contact remote\n");
-            return result;
-        }
-        *id = reply.readInt32();
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t free(uint32_t id)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeInt32(id);
-        status_t result = remote()->transact(GUI_EXT_FREE, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("free could not contact remote\n");
-            return -1;
-        }
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t acquire(const sp<IBinder>& token, uint32_t poolId, uint32_t usage, uint32_t type, int *buf)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeStrongBinder(token);
-        data.writeInt32(poolId);
-        data.writeInt32(usage);
-        data.writeInt32(type);
-        status_t result = remote()->transact(GUI_EXT_ACQUIRE, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("acquire could not contact remote\n");
-            return result;
-        }
-        *buf = reply.readInt32();
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t request(uint32_t poolId, uint32_t usage, uint32_t type, int buf, sp<GraphicBuffer>* buffer)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeInt32(poolId);
-        data.writeInt32(usage);
-        data.writeInt32(type);
-        data.writeInt32(buf);
-        status_t result =remote()->transact(GUI_EXT_REQUEST, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("request could not contact remote\n");
-            return result;
-        }
-        bool nonNull = reply.readInt32();
-        if (nonNull) {
-            *buffer = new GraphicBuffer();
-            result = reply.read(**buffer);
-            if(result != NO_ERROR) {
-                (*buffer).clear();
-                return result;
-            }
-        }
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t release(uint32_t poolId, uint32_t usage, uint32_t type, int buf)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeInt32(poolId);
-        data.writeInt32(usage);
-        data.writeInt32(type);
-        data.writeInt32(buf);
-        status_t result = remote()->transact(GUI_EXT_RELEASE, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("release could not contact remote\n");
-            return result;
-        }
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t disconnect(uint32_t poolId, uint32_t usage, uint32_t type)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeInt32(poolId);
-        data.writeInt32(usage);
-        data.writeInt32(type);
-        status_t result = remote()->transact(GUI_EXT_DISCONNECT, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("disconnect could not contact remote\n");
-            return result;
-        }
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t configDisplay(uint32_t type, bool enable, uint32_t w, uint32_t h, uint32_t bufNum)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeInt32(type);
-        data.writeInt32(enable);
-        data.writeInt32(w);
-        data.writeInt32(h);
-        data.writeInt32(bufNum);
-        status_t result = remote()->transact(GUI_EXT_CONFIGDISPLAY, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("disconnect could not contact remote\n");
-            return result;
-        }
-        result = reply.readInt32();
-        return result;
-    }
-    virtual status_t regDump(const sp<IDumpTunnel>& tunnel, const String8& key)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeStrongBinder(tunnel->asBinder(tunnel));
-        data.writeString8(key);
-        remote()->transact(GUI_EXT_REGDUMP, data, &reply);
-        return reply.readInt32();
-    }
-
-    virtual status_t unregDump(const String8& key)
-    {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGuiExtService::getInterfaceDescriptor());
-        data.writeString8(key);
-        remote()->transact(GUI_EXT_UNREGDUMP, data, &reply);
-        return reply.readInt32();
-    }
-};
-
-IMPLEMENT_META_INTERFACE(GuiExtService, "GuiExtService");
-
-status_t BnGuiExtService::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
-{
-    //ALOGD("receieve the command code %d", code);
-
-    switch(code)
-    {
-        case GUI_EXT_ALLOC:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            sp<IBinder> token = data.readStrongBinder();
-            int gralloc_usage   = data.readInt32();
-            int w = data.readInt32();
-            int h = data.readInt32();
-            uint32_t id;
-            status_t ret = alloc(token, gralloc_usage, w, h, &id);
-            reply->writeInt32(id);
-            reply->writeInt32(ret);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_FREE:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            int id          = data.readInt32();
-            status_t ret = free(id);
-            reply->writeInt32(ret);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_ACQUIRE:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            sp<IBinder> token = data.readStrongBinder();
-            uint32_t poolId = data.readInt32();
-            uint32_t usage = data.readInt32();
-            uint32_t type = data.readInt32();
-            int buf;
-            int result = acquire(token, poolId, usage, type, &buf);
-            reply->writeInt32(buf);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_REQUEST:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            uint32_t poolId = data.readInt32();
-            uint32_t usage = data.readInt32();
-            uint32_t type = data.readInt32();
-            uint32_t buf = data.readInt32();
-            sp<GraphicBuffer> buffer;
-            int result = request(poolId, usage, type, buf, &buffer);
-            reply->writeInt32(buffer != 0);
-            if (buffer != 0) {
-                reply->write(*buffer);
-            }
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_RELEASE:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            uint32_t poolId = data.readInt32();
-            uint32_t usage = data.readInt32();
-            uint32_t type = data.readInt32();
-            uint32_t buf = data.readInt32();
-            int result = release(poolId, usage, type, buf);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_DISCONNECT:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            uint32_t poolId = data.readInt32();
-            uint32_t usage = data.readInt32();
-            uint32_t type = data.readInt32();
-            int result = disconnect(poolId, usage, type);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_CONFIGDISPLAY:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            uint32_t type = data.readInt32();
-            bool enable = data.readInt32();
-            uint32_t w = data.readInt32();
-            uint32_t h = data.readInt32();
-            uint32_t bufNum = data.readInt32();
-            int result = configDisplay(type, enable, w, h, bufNum);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_REGDUMP:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            sp<IDumpTunnel> tunnel = interface_cast<IDumpTunnel>(data.readStrongBinder());
-            String8 key = data.readString8();
-            status_t result = regDump(tunnel, key);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-        case GUI_EXT_UNREGDUMP:
-        {
-            CHECK_INTERFACE(IGuiExtService, data, reply);
-            String8 key = data.readString8();
-            status_t result = unregDump(key);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        break;
-    }
-    return BBinder::onTransact(code, data, reply, flags);
-}
-
-sp<IGuiExtService> checkGuiExtService()
-{
-    const sp<IServiceManager> sm = defaultServiceManager();
-    if (sm != NULL) {
-        // use non-blocking way to get GuiExtService with ServiceManager
-        sp<IBinder> binder = sm->checkService(String16("GuiExtService"));
-        if (binder != NULL) {
-            return interface_cast<IGuiExtService>(binder);
-        }
-        ALOGW("Cannot find GuiExtService");
-        return NULL;
-    }
-    ALOGW("Cannot find default ServiceManager");
-    return NULL;
-}
-};
-
-using namespace android;
-
-bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key)
-{
-#ifndef MTK_DO_NOT_USE_GUI_EXT
-    bool result = false;
-    sp<IGuiExtService> guiExt = checkGuiExtService();
-    if (guiExt != NULL) {
-        result = (guiExt->regDump(tunnel, key) == NO_ERROR);
-    }
-    return result;
-#endif
-}
-
-bool unregDump(const String8& key)
-{
-#ifndef MTK_DO_NOT_USE_GUI_EXT
-    bool result = false;
-    sp<IGuiExtService> guiExt = checkGuiExtService();
-    if (guiExt != NULL) {
-        result = (guiExt->unregDump(key) == NO_ERROR);
-    }
-    return result;
-#endif
-}
diff --git a/gui_ext/lib/NOTICE b/gui_ext/lib/NOTICE
deleted file mode 100755
index 0519ecb..0000000
--- a/gui_ext/lib/NOTICE
+++ /dev/null
@@ -1 +0,0 @@
- 
\ No newline at end of file
diff --git a/gui_ext/lib/README b/gui_ext/lib/README
deleted file mode 100755
index ff42814..0000000
--- a/gui_ext/lib/README
+++ /dev/null
@@ -1,37 +0,0 @@
-GuiExtService support the conversion pool to preallocate buffer for video playback
-
-WHAT IT DOES?
-=============
-
-Some processes notifies GuiExtService whether video is playing or not
-If yes, GuiExtService is going to preallocate buffer for the follow-up stages
-instead of allocating when needing buffers
-
-HOW IT WAS BUILT?
-==================
-
-It needs the following libs from AOSP:
-1.  libutils.so
-2.  libcutils.so
-3.  libbinder.so
-4.  libhardware.so
-5.  libhardware_legacy.so
-5.  libgui.so
-6.  libui.so
-7.  libdl.so
-8.  libion.so
-
-and the following libs from MediaTek:
-1.  libion_mtk.so
-2.  libgralloc_extra.so
-
-All source/dependency modules of this module are already put in
-'vendor/mediatek/proprietary/hardware/gui_ext/' folder.
-
-
-HOW TO USE IT?
-==============
-
-just link the libguiext.so
-
-All the source code of this library were written by MediaTek co..
diff --git a/lineage.mk b/lineage.mk
index 8039d9d..aa4acb7 100644
--- a/lineage.mk
+++ b/lineage.mk
@@ -1,8 +1,10 @@
+# Inherit some 64-bit stuff
 $(call inherit-product, $(SRC_TARGET_DIR)/product/core_64_bit.mk)
 
 # Inherit from the common Open Source product configuration
 $(call inherit-product, $(SRC_TARGET_DIR)/product/full_base_telephony.mk)
 
+# Inherit some language stuff
 $(call inherit-product, $(SRC_TARGET_DIR)/product/languages_full.mk)
 
 # Inherit from hardware-specific part of the product configuration
@@ -12,17 +14,17 @@ $(call inherit-product, device/vernee/apollo_lite/device.mk)
 $(call inherit-product, vendor/cm/config/common_full_phone.mk)
 
 
-# Release name
+# Release Name
 PRODUCT_RELEASE_NAME := apollo_lite
 
 PRODUCT_DEVICE := apollo_lite
 PRODUCT_NAME := lineage_apollo_lite
 PRODUCT_BRAND := Vernee
-PRODUCT_MODEL := Apollo_Lite
+PRODUCT_MODEL := Apollo Lite
 PRODUCT_MANUFACTURER := Vernee
 PRODUCT_RESTRICT_VENDOR_FILES := false
 
-# Boot animation
+# Bootanimation
 TARGET_SCREEN_HEIGHT      := 1920
 TARGET_SCREEN_WIDTH       := 1080
 TARGET_BOOTANIMATION_NAME := 1080
diff --git a/product/audio.mk b/product/audio.mk
deleted file mode 100644
index 0507f76..0000000
--- a/product/audio.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-# Audio
-PRODUCT_PACKAGES += \
-    audio_policy.default \
-    audio.r_submix.default \
-    audio.a2dp.default \
-    audio.usb.default
-
-PRODUCT_COPY_FILES += \
-    frameworks/av/services/audiopolicy/config/audio_policy_volumes.xml:/system/etc/audio_policy_volumes.xml \
-    frameworks/av/services/audiopolicy/config/default_volume_tables.xml:/system/etc/default_volume_tables.xml \
-    frameworks/av/services/audiopolicy/config/r_submix_audio_policy_configuration.xml:/system/etc/r_submix_audio_policy_configuration.xml \
-    frameworks/av/services/audiopolicy/config/usb_audio_policy_configuration.xml:/system/etc/usb_audio_policy_configuration.xml
-
-# Codecs
-PRODUCT_COPY_FILES += \
-    frameworks/av/media/libstagefright/data/media_codecs_google_audio.xml:system/etc/media_codecs_google_audio.xml \
-    frameworks/av/media/libstagefright/data/media_codecs_google_telephony.xml:system/etc/media_codecs_google_telephony.xml \
-    frameworks/av/media/libstagefright/data/media_codecs_google_video_le.xml:system/etc/media_codecs_google_video_le.xml
diff --git a/product/browser.mk b/product/browser.mk
deleted file mode 100644
index 6abed1c..0000000
--- a/product/browser.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-# Browser
-PRODUCT_PACKAGES += \
-    Gello
diff --git a/product/camera.mk b/product/camera.mk
deleted file mode 100644
index af245a2..0000000
--- a/product/camera.mk
+++ /dev/null
@@ -1,12 +0,0 @@
-# Camera
-PRODUCT_COPY_FILES += \
-    $(LOCAL_PATH)/camera/camerasize.xml:system/etc/camerasize.xml \
-    frameworks/native/data/etc/android.hardware.camera.flash-autofocus.xml:system/etc/permissions/android.hardware.camera.flash-autofocus.xml \
-    frameworks/native/data/etc/android.hardware.camera.front.xml:system/etc/permissions/android.hardware.camera.front.xml \
-    frameworks/native/data/etc/android.hardware.camera.raw.xml:system/etc/permissions/android.hardware.camera.raw.xml \
-    $(LOCAL_PATH)/configs/permissions/android.hardware.camera.xml:system/etc/permissions/android.hardware.camera.xml
-# Snap
-PRODUCT_PACKAGES += \
-    Snap
-
-
diff --git a/product/dalvik.mk b/product/dalvik.mk
deleted file mode 100644
index 9986659..0000000
--- a/product/dalvik.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-# Dalvik
-PRODUCT_TAGS += dalvik.gc.type-precise
diff --git a/product/display.mk b/product/display.mk
deleted file mode 100644
index 94c14aa..0000000
--- a/product/display.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-# Display
-PRODUCT_PACKAGES += \
-    libion
diff --git a/product/fingerprint.mk b/product/fingerprint.mk
deleted file mode 100644
index b1df3c3..0000000
--- a/product/fingerprint.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-# Fingerprint
-PRODUCT_COPY_FILES += \
-    frameworks/native/data/etc/android.hardware.fingerprint.xml:system/etc/permissions/android.hardware.fingerprint.xml
-
-PRODUCT_PACKAGES += \
-    fingerprintd
diff --git a/product/fm.mk b/product/fm.mk
deleted file mode 100644
index fcfa2c9..0000000
--- a/product/fm.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-# FMRadio
-MTK_FM_SUPPORT := true
-
-PRODUCT_PACKAGES += \
-    libfmjni \
-    FMRadio
diff --git a/product/fs_manag.mk b/product/fs_manag.mk
deleted file mode 100644
index 5eb4041..0000000
--- a/product/fs_manag.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-# Filesystem management tools
-PRODUCT_PACKAGES += \
-    e2fsck \
-    fsck.f2fs \
-    mkfs.f2fs \
-    make_ext4fs
-
-# exFAT
-PRODUCT_PACKAGES += \
-    mount.exfat \
-    fsck.exfat \
-    mkfs.exfat
-
-# NTFS
-PRODUCT_PACKAGES += \
-    fsck.ntfs \
-    mkfs.ntfs \
-    mount.ntfs
diff --git a/product/gps.mk b/product/gps.mk
deleted file mode 100644
index 2a3eb8c..0000000
--- a/product/gps.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-# GPS
-PRODUCT_COPY_FILES += \
-    frameworks/native/data/etc/android.hardware.location.gps.xml:system/etc/permissions/android.hardware.location.gps.xml
-
-PRODUCT_COPY_FILES += \
-    $(LOCAL_PATH)/configs/agps_profiles_conf2.xml:system/etc/agps_profiles_conf2.xml
diff --git a/product/hardware.mk b/product/hardware.mk
deleted file mode 100644
index 585de4b..0000000
--- a/product/hardware.mk
+++ /dev/null
@@ -1,13 +0,0 @@
-# Hardware-specific permissions
-PRODUCT_COPY_FILES += \
-    frameworks/native/data/etc/android.hardware.vulkan.level-0.xml:system/etc/permissions/android.hardware.vulkan.level.xml \
-    frameworks/native/data/etc/android.hardware.vulkan.version-1_0_3.xml:system/etc/permissions/android.hardware.vulkan.version.xml
-
-# Mediatek
-PRODUCT_PACKAGES += \
-    libstlport \
-    libgralloc_extra \
-    libgui_ext \
-    libui_ext \
-    libmtk_symbols \
-    libxlog
diff --git a/product/permissions.mk b/product/permissions.mk
deleted file mode 100644
index 40ddbf9..0000000
--- a/product/permissions.mk
+++ /dev/null
@@ -1,13 +0,0 @@
-# Permissions
-PRODUCT_COPY_FILES += \
-    frameworks/native/data/etc/handheld_core_hardware.xml:system/etc/permissions/handheld_core_hardware.xml \
-    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.jazzhand.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.jazzhand.xml \
-    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.distinct.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.distinct.xml \
-    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.xml \
-    frameworks/native/data/etc/android.hardware.touchscreen.xml:system/etc/permissions/android.hardware.touchscreen.xml \
-    frameworks/native/data/etc/android.hardware.usb.accessory.xml:system/etc/permissions/android.hardware.usb.accessory.xml \
-    frameworks/native/data/etc/android.hardware.bluetooth.xml:system/etc/permissions/android.hardware.bluetooth.xml \
-    frameworks/native/data/etc/android.hardware.bluetooth_le.xml:system/etc/permissions/android.hardware.bluetooth_le.xml \
-    frameworks/native/data/etc/android.hardware.telephony.cdma.xml:system/etc/permissions/android.hardware.telephony.cdma.xml \
-    frameworks/native/data/etc/android.hardware.telephony.gsm.xml:system/etc/permissions/android.hardware.telephony.gsm.xml \
-    frameworks/native/data/etc/android.hardware.usb.host.xml:system/etc/permissions/android.hardware.usb.host.xml
diff --git a/product/power.mk b/product/power.mk
deleted file mode 100644
index 3f63f7c..0000000
--- a/product/power.mk
+++ /dev/null
@@ -1,8 +0,0 @@
-# Charger
-PRODUCT_PACKAGES += \
-    charger
-
-# Power
-PRODUCT_PACKAGES += \
-    power.default \
-    power.mt6797
diff --git a/product/prop.mk b/product/prop.mk
deleted file mode 100644
index 3ed9f59..0000000
--- a/product/prop.mk
+++ /dev/null
@@ -1,12 +0,0 @@
-# Default.prop
-PRODUCT_DEFAULT_PROPERTY_OVERRIDES += \
-    ro.secure=0 \
-    ro.allow.mock.location=1 \
-    ro.debuggable=1 \
-    ro.adb.secure=0 \
-    persist.service.acm.enable=0 \
-    ro.oem_unlock_supported=1 \
-    ro.mount.fs=EXT4 \
-    persist.service.acm.enable=0 \
-    persist.sys.dun.override=0 \
-    camera.disable_zsl_mode=1
diff --git a/product/ril.mk b/product/ril.mk
deleted file mode 100644
index 4dc206c..0000000
--- a/product/ril.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-# RIL
-PRODUCT_PROPERTY_OVERRIDES += \
-    ro.kernel.android.checkjni=0 \
-    ro.telephony.ril_class=MediaTekRIL \
-    ro.telephony.ril.config=fakeiccid \
-    ro.com.android.mobiledata=false
diff --git a/product/sensors.mk b/product/sensors.mk
deleted file mode 100644
index 89d81f7..0000000
--- a/product/sensors.mk
+++ /dev/null
@@ -1,13 +0,0 @@
-# Sensors
-PRODUCT_COPY_FILES += \
-    frameworks/native/data/etc/android.hardware.sensor.accelerometer.xml:system/etc/permissions/android.hardware.sensor.accelerometer.xml \
-    frameworks/native/data/etc/android.hardware.sensor.compass.xml:system/etc/permissions/android.hardware.compass.xml \
-    frameworks/native/data/etc/android.hardware.sensor.light.xml:system/etc/permissions/android.hardware.sensor.light.xml \
-    frameworks/native/data/etc/android.hardware.sensor.gyroscope.xml:system/etc/permissions/android.hardware.sensor.gyroscope.xml \
-    frameworks/native/data/etc/android.hardware.sensor.proximity.xml:system/etc/permissions/android.hardware.sensor.proximity.xml \
-    frameworks/native/data/etc/android.hardware.sensor.stepcounter.xml:system/etc/permissions/android.hardware.sensor.stepcounter.xml \
-    frameworks/native/data/etc/android.hardware.sensor.stepdetector.xml:system/etc/permissions/android.hardware.sensor.stepdetector.xml
-
-# Sensor Calibration
-PRODUCT_PACKAGES += \
-    libem_sensor_jni
diff --git a/product/telecomm.mk b/product/telecomm.mk
deleted file mode 100644
index a1f8c03..0000000
--- a/product/telecomm.mk
+++ /dev/null
@@ -1,14 +0,0 @@
-# Configurations
-PRODUCT_COPY_FILES += \
-    $(LOCAL_PATH)/configs/apns-conf.xml:system/etc/apns-conf.xml \
-    $(LOCAL_PATH)/configs/ecc_list.xml:system/etc/ecc_list.xml \
-    $(LOCAL_PATH)/configs/spn-conf.xml:system/etc/spn-conf.xml
-
-PRODUCT_PACKAGES += \
-    messaging \
-    Stk
-
-# Radio dependencies
-PRODUCT_PACKAGES += \
-    muxreport \
-    terservice
diff --git a/product/tethering.mk b/product/tethering.mk
deleted file mode 100644
index f0ebbc3..0000000
--- a/product/tethering.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-# Tethering
-PRODUCT_PROPERTY_OVERRIDES += \
-    net.tethering.noprovisioning=true
diff --git a/product/thermal.mk b/product/thermal.mk
deleted file mode 100644
index cf87c8f..0000000
--- a/product/thermal.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-# Thermal
-PRODUCT_COPY_FILES += \
-    $(LOCAL_PATH)/configs/thermal/.ht120.mtc:system/etc/.tp/.ht120.mtc \
-    $(LOCAL_PATH)/configs/thermal/thermal.conf:system/etc/.tp/thermal.conf \
-    $(LOCAL_PATH)/configs/thermal/thermal.off.conf:system/etc/.tp/thermal.off.conf \
-    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_00 \
-    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_01 \
-    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_02 \
-    $(LOCAL_PATH)/configs/thermal/.thermal_policy_00:system/etc/.tp/.thermal_policy_03
diff --git a/product/usb.mk b/product/usb.mk
deleted file mode 100644
index 93068fd..0000000
--- a/product/usb.mk
+++ /dev/null
@@ -1,4 +0,0 @@
-# USB
-PRODUCT_PACKAGES += \
-    librs_jni \
-    com.android.future.usb.accessory
diff --git a/product/wallpaper.mk b/product/wallpaper.mk
deleted file mode 100644
index d733178..0000000
--- a/product/wallpaper.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-# WallpaperPicker
-PRODUCT_PACKAGES += \
-    WallpaperPicker
diff --git a/product/wifi.mk b/product/wifi.mk
deleted file mode 100644
index 60264ba..0000000
--- a/product/wifi.mk
+++ /dev/null
@@ -1,15 +0,0 @@
-# Wifi
-PRODUCT_COPY_FILES += \
-    frameworks/native/data/etc/android.hardware.wifi.xml:system/etc/permissions/android.hardware.wifi.xml \
-    frameworks/native/data/etc/android.hardware.wifi.direct.xml:system/etc/permissions/android.hardware.wifi.direct.xml
-
-PRODUCT_PACKAGES += \
-    lib_driver_cmd_mt66xx \
-    libwpa_client \
-    hostapd \
-    wpa_supplicant
-
-PRODUCT_COPY_FILES += \
-    $(LOCAL_PATH)/configs/wifi/wpa_supplicant.conf:system/etc/wifi/wpa_supplicant.conf \
-    $(LOCAL_PATH)/configs/wifi/wpa_supplicant_overlay.conf:system/etc/wifi/wpa_supplicant_overlay.conf \
-    $(LOCAL_PATH)/configs/wifi/p2p_supplicant_overlay.conf:system/etc/wifi/p2p_supplicant_overlay.conf
diff --git a/ui_ext/Android.mk b/ui_ext/Android.mk
deleted file mode 100755
index f25cc12..0000000
--- a/ui_ext/Android.mk
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright Statement:
-#
-# This software/firmware and related documentation ("MediaTek Software") are
-# protected under relevant copyright laws. The information contained herein
-# is confidential and proprietary to MediaTek Inc. and/or its licensors.
-# Without the prior written permission of MediaTek inc. and/or its licensors,
-# any reproduction, modification, use or disclosure of MediaTek Software,
-# and information contained herein, in whole or in part, shall be strictly prohibited.
-
-# MediaTek Inc. (C) 2010. All rights reserved.
-#
-# BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-# THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-# RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
-# AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-# NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-# SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-# SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
-# THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
-# THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
-# CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
-# SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
-# STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
-# CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-# AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-# OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
-# MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-#
-# The following software/firmware and/or related documentation ("MediaTek Software")
-# have been modified by MediaTek Inc. All revisions are subject to any receiver's
-# applicable license agreements with MediaTek Inc.
-
-
-include $(call all-subdir-makefiles)
-
diff --git a/ui_ext/NOTICE b/ui_ext/NOTICE
deleted file mode 100755
index 0519ecb..0000000
--- a/ui_ext/NOTICE
+++ /dev/null
@@ -1 +0,0 @@
- 
\ No newline at end of file
diff --git a/ui_ext/README b/ui_ext/README
deleted file mode 100755
index bf0a97a..0000000
--- a/ui_ext/README
+++ /dev/null
@@ -1,31 +0,0 @@
-This directory contains some utilities functions
-
-WHAT IT DOES?
-=============
-
-The library implements some utilties function for debugging
-
-
-HOW IT WAS BUILT?
-==================
-
-It needs the following libs from AOSP:
-1.  libpng.so
-2.  libutils.so
-3.  libui.so
-4.  libcutils.so
-5.  libhardware.so
-
-and the following libs from MediaTek:
-4.  libgralloc_extra.so
-
-All source/dependency modules of this module are already put in
-'vendor/mediatek/proprietary/hardware/ui_ext/lib' folder.
-
-
-HOW TO USE IT?
-==============
-
-just link the libui_ext.so
-
-All the source code of this library were written by MediaTek co..
diff --git a/ui_ext/inc/FpsCounter.h b/ui_ext/inc/FpsCounter.h
deleted file mode 100755
index 29bf03f..0000000
--- a/ui_ext/inc/FpsCounter.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_GUI_FPSCOUNTER_H
-#define ANDROID_GUI_FPSCOUNTER_H
-
-namespace android {
-// ----------------------------------------------------------------------------
-
-// tool class for FPS statistics, provide AVG, MAX, MIN message
-// * AVG for FPS in a given duration
-// * MAX and MIN for stability reference
-class FpsCounter {
-private:
-    // for AVG
-    float       mFps;
-
-    // for MAX, MIN
-    nsecs_t     mMaxDuration;
-    nsecs_t     mMinDuration;
-    nsecs_t     mMaxDurationCounting;
-    nsecs_t     mMinDurationCounting;
-
-    // per interval result
-    uint32_t    mFrames;
-    nsecs_t     mLastLogTime;
-    nsecs_t     mLastLogDuration;
-
-    // per update result
-    nsecs_t     mLastTime;
-    nsecs_t     mLastDuration;
-
-public:
-    // the given counting interval, read system property by default
-    nsecs_t     mCountInterval;
-
-    FpsCounter() { reset(); }
-    ~FpsCounter() {}
-
-    // main control
-    bool reset();
-    bool update(nsecs_t time);
-    bool update();
-
-    // get result
-    inline float   getFps()             { return mFps;             }
-    inline nsecs_t getMaxDuration()     { return mMaxDuration;     }
-    inline nsecs_t getMinDuration()     { return mMinDuration;     }
-    inline nsecs_t getLastLogDuration() { return mLastLogDuration; }
-    inline nsecs_t getLastDuration()    { return mLastDuration;    }
-};
-
-// ----------------------------------------------------------------------------
-}; // namespace android
-
-#endif // ANDROID_GUI_FPSCOUNTER_H
diff --git a/ui_ext/inc/GraphicBufferUtil.h b/ui_ext/inc/GraphicBufferUtil.h
deleted file mode 100755
index f40071f..0000000
--- a/ui_ext/inc/GraphicBufferUtil.h
+++ /dev/null
@@ -1,68 +0,0 @@
-#ifndef ANDROID_MTK_GRAPHIC_BUFFER_UTIL_H
-#define ANDROID_MTK_GRAPHIC_BUFFER_UTIL_H
-#include <utils/Singleton.h>
-
-#include <ui/PixelFormat.h>
-
-#include <hardware/gralloc_extra.h>
-
-namespace android {
-// ---------------------------------------------------------------------------
-class GraphicBuffer;
-
-class BufferInfo
-{
-private:
-    int mErr;
-
-public:
-    int mWidth;
-    int mHeight;
-    int mStride;
-    int mFormat;
-    buffer_handle_t mHandle;
-
-    BufferInfo() : mErr(NO_ERROR)
-    {
-    }
-
-    status_t getInfo(const buffer_handle_t& handle);
-    status_t getInfo(const sp<GraphicBuffer>& gb);
-};
-
-class GraphicBufferUtil : public Singleton<GraphicBufferUtil>
-{
-public:
-    static inline GraphicBufferUtil& get() { return getInstance(); }
-
-    /** @brief dump the GraphicBuffer
-     *
-     * @param prefix the prefix of file name
-     * @param dir the stored directory, default is "/data/"
-     */
-    void dump(const buffer_handle_t& handle, const char* prefix = "", const char* dir = "/data/");
-    void dump(const sp<GraphicBuffer>& gb, const char* prefix = "", const char* dir = "/data/");
-    void dump(const BufferInfo &handle, const char* prefix = "", const char* dir = "/data/");
-
-    uint32_t getBitsPerPixel(int format);
-    uint32_t getBitsPerPixel(buffer_handle_t handle);
-    int getRealFormat(buffer_handle_t handle, PixelFormat* format);
-
-    int drawLine(const buffer_handle_t& handle, uint8_t val, int ptn_w, int ptn_h, int pos);
-    int drawLine(const sp<GraphicBuffer>& gb, uint8_t val, int ptn_w, int ptn_h, int pos);
-    int drawLine(const BufferInfo &handle, uint8_t val, int ptn_w, int ptn_h, int pos);
-
-private:
-    friend class Singleton<GraphicBufferUtil>;
-
-    GraphicBufferUtil();
-    ~GraphicBufferUtil();
-};
-
-inline GraphicBufferUtil& getGraphicBufferUtil() {
-    return GraphicBufferUtil::get();
-}
-// ---------------------------------------------------------------------------
-}; // namespace android
-
-#endif // ANDROID_MTK_GRAPHIC_BUFFER_UTIL_H
diff --git a/ui_ext/inc/IDumpTunnel.h b/ui_ext/inc/IDumpTunnel.h
deleted file mode 100755
index 8f9b663..0000000
--- a/ui_ext/inc/IDumpTunnel.h
+++ /dev/null
@@ -1,49 +0,0 @@
-#ifndef ANDROID_GUI_IDUMPTUNNEL_H
-#define ANDROID_GUI_IDUMPTUNNEL_H
-
-#include <binder/IInterface.h>
-#include <utils/Singleton.h>
-
-namespace android
-{
-
-class IDumpTunnel : public IInterface {
-protected:
-    enum {
-        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
-    };
-
-public:
-    DECLARE_META_INTERFACE(DumpTunnel);
-
-    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
-};
-
-class BnDumpTunnel : public BnInterface<IDumpTunnel>
-{
-    virtual status_t onTransact(uint32_t code,
-                                const Parcel& data,
-                                Parcel* reply,
-                                uint32_t flags = 0);
-};
-
-// helper class for libgui_ext dynamic linking
-class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
-    void* mSoHandle;
-    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
-    bool (*mUnregDumpPtr)(const String8&);
-
-public:
-    DumpTunnelHelper();
-    virtual ~DumpTunnelHelper();
-
-    // register tunnel into guiext-server with a given key name
-    // and need to unregister it back
-    // in general usage, need to use identical key name for reg/unreg pair
-    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
-    bool unregDump(const String8& key);
-};
-
-
-};
-#endif
diff --git a/ui_ext/inc/RWTable.h b/ui_ext/inc/RWTable.h
deleted file mode 100755
index 70c3b75..0000000
--- a/ui_ext/inc/RWTable.h
+++ /dev/null
@@ -1,52 +0,0 @@
-#ifndef ANDROID_MTK_RWTABLE_H
-#define ANDROID_MTK_RWTABLE_H
-#include <utils/Singleton.h>
-#include <utils/KeyedVector.h>
-#include <utils/RefBase.h>
-#include <utils/RWLock.h>
-
-namespace android {
-template <typename KeyType, typename ValueType>
-class RWTable {
-public:
-    RWTable() :
-        mMap(NULL)
-    {
-    }
-
-    sp<ValueType> operator[] (KeyType const key) {
-        ssize_t idx = 0;
-        sp<ValueType> value = NULL;
-        {
-            RWLock::AutoRLock l(mLock);
-            idx = mMap.indexOfKey(key);
-            if (idx >= 0) {
-                value = mMap.editValueAt(idx);
-            }
-        }
-        if (idx < 0) {
-            value = createEntry();
-            {
-                RWLock::AutoWLock l(mLock);
-                mMap.add(key, value);
-            }
-        }
-        return value;
-    }
-
-    bool remove(KeyType const key) {
-        RWLock::AutoWLock l(mLock);
-        return mMap.removeItem(key) >= 0 ? true : false;
-    }
-
-    virtual ~RWTable() {
-    }
-
-protected:
-    virtual sp<ValueType> createEntry() = 0;
-    DefaultKeyedVector<KeyType, sp<ValueType> > mMap;
-    RWLock mLock;
-};
-
-}; // namespace android
-#endif // ANDROID_MTK_RWTABLE_H
diff --git a/ui_ext/inc/RefBaseDump.h b/ui_ext/inc/RefBaseDump.h
deleted file mode 100755
index c127368..0000000
--- a/ui_ext/inc/RefBaseDump.h
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifndef ANDROID_REFBASE_DUMP_H__
-#define ANDROID_REFBASE_DUMP_H__
-
-#include <utils/String8.h>
-#include <utils/KeyedVector.h>
-#include <utils/Singleton.h>
-#include <IDumpTunnel.h>
-
-namespace android
-{
-class RefBaseMonitor;
-
-//-------------------------------------------------------------------------
-// RefBaseDump
-//-------------------------------------------------------------------------
-class RefBaseDump : public BnDumpTunnel {
-
-public:
-    RefBaseDump(RefBaseMonitor*);
-    virtual ~RefBaseDump();
-
-    // IDumpTunnel interface
-    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/);
-
-private:
-    RefBaseMonitor *mMonitor;
-};
-
-//-------------------------------------------------------------------------
-// RefBaseMonitor
-//-------------------------------------------------------------------------
-class RefBaseMonitor : public Singleton<RefBaseMonitor> {
-public:
-    RefBaseMonitor();
-    virtual ~RefBaseMonitor();
-
-    // add refbase to the monitored list
-    status_t monitor(RefBase* );
-
-    // remove refbase from the monitored list
-    status_t unmonitor(RefBase* );
-
-    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
-    status_t dump(String8& result);
-
-private:
-    status_t getProcessName();
-
-    // if trackMe needed
-    bool mIsTracking;
-
-    String8 mProcessName;
-
-    sp<RefBaseDump> mDump;
-
-    // the list where monitored refbase objects are saved
-    KeyedVector<RefBase*,int> RbList;
-
-    mutable Mutex mMutex;;
-};
-
-};
-#endif
diff --git a/ui_ext/lib/Android.mk b/ui_ext/lib/Android.mk
deleted file mode 100755
index e130606..0000000
--- a/ui_ext/lib/Android.mk
+++ /dev/null
@@ -1,72 +0,0 @@
-# Copyright Statement:
-#
-# This software/firmware and related documentation ("MediaTek Software") are
-# protected under relevant copyright laws. The information contained herein
-# is confidential and proprietary to MediaTek Inc. and/or its licensors.
-# Without the prior written permission of MediaTek inc. and/or its licensors,
-# any reproduction, modification, use or disclosure of MediaTek Software,
-# and information contained herein, in whole or in part, shall be strictly prohibited.
-#
-# MediaTek Inc. (C) 2010. All rights reserved.
-#
-# BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-# THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-# RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
-# AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-# NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-# SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-# SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
-# THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
-# THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
-# CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
-# SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
-# STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
-# CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-# AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-# OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
-# MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-#
-# The following software/firmware and/or related documentation ("MediaTek Software")
-# have been modified by MediaTek Inc. All revisions are subject to any receiver's
-# applicable license agreements with MediaTek Inc.
-
-
-#
-# libui_extra.so
-# modified by daniel_hk(https://github.com/daniel_hk)
-
-LOCAL_PATH:= $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	GraphicBufferUtil.cpp \
-	FpsCounter.cpp \
-	IDumpTunnel.cpp \
-	RefBaseDump.cpp
-
-LOCAL_C_INCLUDES:= \
-	device/vernee/apollo_lite/ui_ext/inc \
-	device/vernee/apollo_lite/gralloc_extra/include \
-	external/libpng \
-	external/zlib \
-	external/skia/src/images \
-	external/skia/include/core
-
-LOCAL_SHARED_LIBRARIES := \
-	libpng \
-	libutils \
-	libui \
-	libcutils \
-	libhardware \
-	libgralloc_extra \
-	libbinder \
-	libdl
-
-LOCAL_MODULE := libui_ext
-
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/ui_ext/lib/FpsCounter.cpp b/ui_ext/lib/FpsCounter.cpp
deleted file mode 100755
index 95db413..0000000
--- a/ui_ext/lib/FpsCounter.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-#include <stdint.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <utils/CallStack.h>
-#include <utils/Errors.h>
-#include <utils/Log.h>
-#include <utils/threads.h>
-
-#include <cutils/properties.h>
-
-#include <FpsCounter.h>
-
-
-namespace android {
-
-//--------------------------------------------------------------------------------------------------
-bool FpsCounter::reset() {
-    mFps = 0.0;
-
-    mMaxDuration = -1;
-    mMinDuration = -1;
-    mMaxDurationCounting = -1;
-    mMinDurationCounting = -1;
-
-    mFrames = 0;
-    mLastLogTime = -1;
-    mLastLogDuration = -1;
-
-    mLastTime = -1;
-    mLastDuration = -1;
-
-    // read property as default log interval setting
-    char value[PROPERTY_VALUE_MAX];
-    property_get("debug.sf.stc_interval", value, "1000");
-    mCountInterval = ms2ns(atoi(value));
-
-    return true;
-}
-
-bool FpsCounter::update() {
-    return update(systemTime(SYSTEM_TIME_MONOTONIC));
-}
-
-bool FpsCounter::update(nsecs_t timestamp) {
-    if ((-1 == mLastLogTime) || (-1 == mLastTime) || (mLastTime >= timestamp)) {
-        mLastLogTime = mLastTime = timestamp;
-        return false;
-    }
-
-    mFrames++;
-
-    // count duration from last time update
-    mLastDuration = timestamp - mLastTime;
-    mLastTime = timestamp;
-    if ((-1 == mMaxDurationCounting) || (mLastDuration > mMaxDurationCounting)) {
-        mMaxDurationCounting = mLastDuration;
-    }
-    if ((-1 == mMinDurationCounting) || (mLastDuration < mMinDurationCounting)) {
-        mMinDurationCounting = mLastDuration;
-    }
-
-    // check if reach statistics interval, print result and reset for next
-    nsecs_t duration = timestamp - mLastLogTime;
-    if (duration > mCountInterval) {
-
-        // update data for FPS result
-        mFps = mFrames * 1e9 / duration;
-        mLastLogDuration = duration;
-        mMaxDuration = mMaxDurationCounting;
-        mMinDuration = mMinDurationCounting;
-
-        // reset counting data for next
-        mFrames = 0;
-        mLastLogTime = timestamp;
-        mMaxDurationCounting = -1;
-        mMinDurationCounting = -1;
-
-        return true;
-    }
-
-    return false;
-}
-
-// ----------------------------------------------------------------------------
-}; // namespace android
diff --git a/ui_ext/lib/GraphicBufferUtil.cpp b/ui_ext/lib/GraphicBufferUtil.cpp
deleted file mode 100755
index 29dfceb..0000000
--- a/ui_ext/lib/GraphicBufferUtil.cpp
+++ /dev/null
@@ -1,592 +0,0 @@
-#define LOG_TAG "GraphicBufferUtil"
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#define MTK_LOG_ENABLE 1
-#include <utils/String8.h>
-
-#include <cutils/log.h>
-
-#include <ui/GraphicBufferExtra.h>
-#include <ui/GraphicBuffer.h>
-#include <ui/GraphicBufferMapper.h>
-
-#include <png.h>
-#include <transform_scanline.h>
-
-#include <GraphicBufferUtil.h>
-#include <graphics_mtk_defs.h>
-
-#define ALIGN_CEIL(x,a) (((x) + (a) - 1L) & ~((a) - 1L))
-#define LOCK_FOR_SW (GRALLOC_USAGE_SW_READ_RARELY | GRALLOC_USAGE_SW_WRITE_RARELY | GRALLOC_USAGE_HW_TEXTURE)
-
-namespace android {
-// ---------------------------------------------------------------------------
-
-ANDROID_SINGLETON_STATIC_INSTANCE( GraphicBufferUtil )
-
-status_t BufferInfo::getInfo(const buffer_handle_t& handle)
-{
-    mHandle = handle;
-    int format = PIXEL_FORMAT_UNKNOWN;
-    int err = NO_ERROR;
-    mErr = gralloc_extra_query(handle, GRALLOC_EXTRA_GET_WIDTH, &mWidth);
-    mErr |= gralloc_extra_query(handle, GRALLOC_EXTRA_GET_HEIGHT, &mHeight);
-    mErr |= gralloc_extra_query(handle, GRALLOC_EXTRA_GET_STRIDE, &mStride);
-    mErr |= gralloc_extra_query(handle, GRALLOC_EXTRA_GET_FORMAT, &mFormat);
-
-    if ((err = getGraphicBufferUtil().getRealFormat(handle, &format)) == GRALLOC_EXTRA_OK)
-    {
-        mFormat = format;
-    }
-    mErr |= err;
-    return mErr;
-}
-
-status_t BufferInfo::getInfo(const sp<GraphicBuffer>& gb)
-{
-    if (NO_ERROR != getInfo(gb->handle))
-    {
-        ALOGD("Can't gralloc_extra handle, fallback to get info from gb!");
-        mHandle = gb->handle;
-        mWidth = gb->width;
-        mHeight = gb->height;
-        mStride = gb->stride;
-        mFormat = gb->format;
-        mErr = NO_ERROR;
-    }
-    return mErr;
-}
-
-GraphicBufferUtil::GraphicBufferUtil()
-{
-}
-
-GraphicBufferUtil::~GraphicBufferUtil()
-{
-}
-
-static void write565Data(uint32_t width,
-                         uint32_t height,
-                         uint8_t* in,
-                         png_structp out)
-{
-    // input is RGB565 for 2 bytes, and output is RGBA8888 for 4 bytes
-    const uint32_t inBPP = 2;
-    const uint32_t outBPP = 4;
-
-    png_bytep tmp = new png_byte[width * outBPP];
-    if (NULL == tmp)
-    {
-        ALOGE("cannot create temp row buffer for RGB565 conversion");
-        return;
-    }
-
-    uint8_t* wptr;
-    for (uint32_t i = 0; i < height; i++)
-    {
-        wptr = reinterpret_cast<uint8_t*>(tmp);
-        for (uint32_t j = 0; j < width; ++j)
-        {
-            // get 16bits pixel value and split it into 32bits storage
-            const uint16_t c = *(reinterpret_cast<uint16_t*>(in));
-            wptr[0] = SkPacked16ToR32(c);
-            wptr[1] = SkPacked16ToG32(c);
-            wptr[2] = SkPacked16ToB32(c);
-            wptr[3] = 255;
-
-            wptr += outBPP;
-            in += inBPP;
-        }
-        png_write_rows(out, &tmp, 1);
-    }
-
-    delete [] tmp;
-}
-
-static void writeData(uint32_t width,
-                      uint32_t height,
-                      uint8_t* in,
-                      png_structp out)
-{
-    // should be RGBA for 4 bytes
-    const uint32_t widthBytes = width * 4;
-
-    for (uint32_t y = 0; y < height; y++)
-    {
-        png_write_rows(out, (png_bytepp)&in, 1);
-        in = (uint8_t *)in + widthBytes;
-    }
-}
-
-void GraphicBufferUtil::dump(const sp<GraphicBuffer>& gb,
-                              const char* prefix,
-                              const char* dir)
-{
-    if (CC_UNLIKELY(gb == NULL))
-    {
-        ALOGE("[%s] gb is NULL", __func__);
-        return;
-    }
-
-    BufferInfo i;
-    i.getInfo(gb);
-
-    dump(i, prefix, dir);
-}
-
-void GraphicBufferUtil::dump(const buffer_handle_t &handle,
-                              const char* prefix,
-                              const char* dir)
-{
-    if (CC_UNLIKELY(handle == NULL))
-    {
-        ALOGE("[%s] handle is NULL", __func__);
-        return;
-    }
-
-    BufferInfo i;
-    i.getInfo(handle);
-
-    dump(i, prefix, dir);
-}
-
-void GraphicBufferUtil::dump( const BufferInfo &info,
-                              const char* prefix,
-                              const char* dir)
-{
-    const uint32_t& width = info.mWidth;
-    const uint32_t& height = info.mHeight;
-    const uint32_t& stride = info.mStride;
-    const buffer_handle_t& handle = info.mHandle;
-    const PixelFormat& format = info.mFormat;
-
-    ALOGD("[%s] handle:%p +", __func__, handle);
-    ALOGD("    prefix: %s dir:%s", prefix, dir);
-
-    // make file name, default path to /data/[handle]_[width]_[height]_[stride]
-    String8 path;
-    if ((NULL == dir) || (0 == strlen(dir)))
-    {
-        path.setPathName("/data/");
-    }
-    else
-    {
-        path.setPathName(dir);
-    }
-
-    if ((NULL == prefix) || (0 == strlen(prefix)))
-    {
-        path.append(String8::format("/H%p_w%d_h%d_s%d",
-            handle, width, height, stride));
-    }
-    else
-    {
-        path.append(String8::format("/%s_H%p_w%d_h%d_s%d",
-            prefix, handle, width, height, stride));
-    }
-    ALOGD("      name: %s", path.string());
-
-    int dumpHeight = height;
-
-    uint32_t bits = getBitsPerPixel(format);
-    bool isRaw = false;
-    bool is565 = false;
-    bool stripAlpha = false;
-
-    // switch case different pixel format process
-    // only RGB? series will be saved into image file
-    // others in RAW data only
-    switch (format)
-    {
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            path += ".png";
-            break;
-        case HAL_PIXEL_FORMAT_RGBX_8888:
-            path += ".png";
-            stripAlpha = true;
-            break;
-        case HAL_PIXEL_FORMAT_BGRA_8888:
-            path += "(RBswapped).png";
-            break;
-        case 0x1ff:                     // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
-            path += "(RBswapped).png";
-            stripAlpha = true;
-            break;
-        case HAL_PIXEL_FORMAT_RGB_565:
-            is565 = true;
-            stripAlpha = true;
-            path += ".png";
-            break;
-        case HAL_PIXEL_FORMAT_I420:
-            isRaw = true;
-            path += ".i420";
-            break;
-        case HAL_PIXEL_FORMAT_NV12_BLK:
-            dumpHeight = ALIGN_CEIL(height, 32);
-            isRaw = true;
-            path += ".nv12_blk";
-            break;
-        case HAL_PIXEL_FORMAT_NV12_BLK_FCM:
-            dumpHeight = ALIGN_CEIL(height, 32);
-            isRaw = true;
-            path += ".nv12_blk_fcm";
-            break;
-        case HAL_PIXEL_FORMAT_YV12:
-            isRaw = true;
-            path += ".yv12";
-            break;
-        case HAL_PIXEL_FORMAT_YUYV:
-            isRaw = true;
-            path += ".yuyv";
-            break;
-        case HAL_PIXEL_FORMAT_RGB_888:
-            isRaw = true;
-            path += ".RGB";
-            break;
-        default:
-            ALOGE("    CANNOT dump (format:0x%x)", format);
-            return;
-    }
-    ALOGD("      path: %s", path.string());
-
-    void        *ptr     = NULL;
-    FILE        *f       = NULL;
-    png_structp png_ptr  = NULL;
-    png_infop   info_ptr = NULL;
-
-    // dump to file with final path and file type
-
-    int err = GraphicBufferMapper::getInstance().lock(handle,
-                                                      GraphicBuffer::USAGE_SW_READ_OFTEN,
-                                                      Rect(width, height),
-                                                      &ptr);
-    if (err == NO_ERROR)
-    {
-        if (NULL == ptr)
-        {
-            ALOGE("    lock() FAILED");
-            goto finalize;
-        }
-
-        f = fopen(path.string(), "wb");
-        if (NULL == f)
-        {
-            ALOGE("    fopen() FAILED");
-            goto finalize;
-        }
-
-        if (isRaw)
-        {
-            if (HAL_PIXEL_FORMAT_YV12 == format)
-            {
-                // need correction for YV12 case, pending for VU planes should also pending to 16
-                uint32_t remainder = (stride / 2) % 16;
-                if (0 != remainder)
-                {
-                    remainder = 16 - remainder;
-                }
-                fwrite(ptr, ((stride * dumpHeight * bits) >> 3) + (remainder * dumpHeight), 1, f);
-            }
-            else
-            {
-                // simplely write binary data to file
-                fwrite(ptr, (stride * dumpHeight * bits) >> 3, 1, f);
-            }
-        }
-        else
-        {
-            // init write struct
-            png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-            if (NULL == png_ptr)
-            {
-                ALOGE("    init png FAILED (1)");
-                goto finalize;
-            }
-
-            // init info struct
-            info_ptr = png_create_info_struct(png_ptr);
-            if (NULL == info_ptr)
-            {
-                ALOGE("    init png FAILED (2)");
-                goto finalize;
-            }
-
-            // set file to write
-            png_init_io(png_ptr, f);
-
-            // setup color format info
-            if (true == stripAlpha)
-            {
-                png_set_IHDR(png_ptr, info_ptr,
-                    stride, dumpHeight, 8, PNG_COLOR_TYPE_RGB,
-                    PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-            }
-            else
-            {
-                png_set_IHDR(png_ptr, info_ptr,
-                    stride, dumpHeight, 8, PNG_COLOR_TYPE_RGB_ALPHA,
-                    PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-            }
-
-            // set bits layout
-            png_color_8 sigBit;
-            if (is565)
-            {
-                sigBit.red   = 5;
-                sigBit.green = 6;
-                sigBit.blue  = 5;
-                sigBit.alpha = 0;
-            }
-            else
-            {
-                sigBit.red   = 8;
-                sigBit.green = 8;
-                sigBit.blue  = 8;
-                sigBit.alpha = 8;
-            }
-            png_set_sBIT(png_ptr, info_ptr, &sigBit);
-
-            // start
-            png_write_info(png_ptr, info_ptr);
-
-            // set filler to get rid of alpha if strip needed
-            if (true == stripAlpha)
-            {
-                png_set_filler(png_ptr, 0x00, PNG_FILLER_AFTER);
-            }
-
-            // write data into png
-            if (is565)
-            {
-                write565Data(stride, height, reinterpret_cast<uint8_t*>(ptr), png_ptr);
-            }
-            else
-            {
-                writeData(stride, height, reinterpret_cast<uint8_t*>(ptr), png_ptr);
-            }
-
-            // end
-            png_write_end(png_ptr, info_ptr);
-        }
-
-finalize:
-        // clean up
-        if (NULL != f)        fclose(f);
-        if (NULL != info_ptr) png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
-        if (NULL != png_ptr)  png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
-    }
-    GraphicBufferMapper::getInstance().unlock(handle);
-
-    ALOGD("[%s] -", __func__);
-}
-
-uint32_t GraphicBufferUtil::getBitsPerPixel(int format)
-{
-    uint32_t bits = 32;
-    switch (format)
-    {
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-        case HAL_PIXEL_FORMAT_RGBX_8888:
-        case HAL_PIXEL_FORMAT_BGRA_8888:
-        case 0x1ff:                     // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
-            bits = 32;
-            break;
-        case HAL_PIXEL_FORMAT_RGB_888:
-            bits = 24;
-            break;
-        case HAL_PIXEL_FORMAT_RGB_565:
-        case HAL_PIXEL_FORMAT_YUYV:
-            bits = 16;
-            break;
-        case HAL_PIXEL_FORMAT_I420:
-        case HAL_PIXEL_FORMAT_NV12_BLK:
-        case HAL_PIXEL_FORMAT_NV12_BLK_FCM:
-        case HAL_PIXEL_FORMAT_YV12:
-        case HAL_PIXEL_FORMAT_YUV_PRIVATE:
-            bits = 12;
-            break;
-        default:
-            ALOGE("    unknown format: 0x%x, use default as 4.0", format);
-    }
-    return bits;
-}
-
-uint32_t GraphicBufferUtil::getBitsPerPixel(buffer_handle_t handle)
-{
-    int32_t format = 0;
-    if (GraphicBufferExtra::get().query(
-                handle,
-                GRALLOC_EXTRA_GET_FORMAT,
-                static_cast<int*>(&format)) != GRALLOC_EXTRA_OK)
-    {
-        ALOGE("Getting format of handle failed");
-        return 0;
-    }
-    return getBitsPerPixel(format);
-}
-
-status_t GraphicBufferUtil::drawLine(const sp<GraphicBuffer>& gb, uint8_t val, int ptn_w, int ptn_h, int pos)
-{
-    if (CC_UNLIKELY(gb == NULL))
-    {
-        ALOGE("[%s] gb is NULL", __func__);
-        return INVALID_OPERATION;
-    }
-
-    BufferInfo i;
-    i.getInfo(gb);
-
-    return drawLine(i, val, ptn_w, ptn_h, pos);
-}
-
-status_t GraphicBufferUtil::drawLine(const buffer_handle_t& handle, uint8_t val, int ptn_w, int ptn_h, int pos)
-{
-    if (CC_UNLIKELY(handle == NULL))
-    {
-        ALOGE("[%s] handle is NULL", __func__);
-        return INVALID_OPERATION;
-    }
-
-    BufferInfo i;
-    i.getInfo(handle);
-
-    return drawLine(i, val, ptn_w, ptn_h, pos);
-}
-
-status_t GraphicBufferUtil::drawLine(const BufferInfo &info, uint8_t val, int ptn_w, int ptn_h, int pos)
-{
-    const uint32_t& width = info.mWidth;
-    const uint32_t& height = info.mHeight;
-    const uint32_t& stride = info.mStride;
-    const buffer_handle_t& handle = info.mHandle;
-    const PixelFormat& format = info.mFormat;
-
-    if (ptn_w == 0)
-        ptn_w = 1;
-    if (ptn_h == 0)
-        ptn_h = 1;
-
-    uint32_t log_w = log2(ptn_w);
-    if (log_w > 5)
-        log_w = 5;
-    uint32_t line_w = pow(2, log_w);
-
-    uint32_t log_h = log2(ptn_h);
-    if (log_h > 5)
-        log_h = 5;
-    uint32_t line_h = pow(2, log_h);
-
-    uintptr_t ptr;
-    int err = GraphicBufferMapper::getInstance().lock(handle,
-                                                      LOCK_FOR_SW,
-                                                      Rect(width, height),
-                                                      (void**)&ptr);
-    if (NO_ERROR != err)
-    {
-        ALOGE("[%s] buffer lock fail: %s (handle:%p)",
-            __func__, strerror(err), handle);
-    }
-    else
-    {
-        // if custom format, just regard as one-byte-plane size
-        // otherwise use accurate size aggressively
-        uint32_t bits = 8;
-        if (format < 0x100)
-        {
-            bits = getBitsPerPixel(format);
-        }
-
-        if (ptn_w == 1)
-        {
-            uint32_t bsize; // block size, will split intrested plane to 32 parts
-
-            pos &= (line_h - 1);    // mod count by 32
-
-            ALOGV("[debug] drawLine, pos=%d, log_h=%d, line_h=%d", pos, log_h, line_h);
-
-            bsize = ((stride * height * bits) >> 3) >> log_h;
-            memset((void*)(ptr + (bsize * pos)), val, bsize);
-        }
-        else
-        {
-            uint32_t block_number = line_w * line_h;
-            uint32_t block_w = width >> log_w;
-            uint32_t block_h = height >> log_h;
-            uint32_t bsize = block_w * block_h;
-            uint32_t pos_x = pos & (line_w - 1);
-            uint32_t pos_y = (pos / line_w) & (line_h - 1);
-            uint32_t j;
-
-            ALOGV("[debug] drawLine pos=%d, log_w=%d, line_w=%d, log_h=%d, line_h=%d, "
-                  "block_number=%d, block_w=%d, block_h=%d, bsize=%d, pos_x=%d, pos_y=%d",
-                pos, log_w, line_w, log_h, line_h, block_number, block_w, block_h, bsize, pos_x, pos_y);
-
-            block_w = (block_w * bits) >> 3;
-            ptr += ((stride * pos_y * block_h * bits) >> 3) + (block_w * pos_x);
-            for (j = 0; j < block_h; j++)
-            {
-                memset((void*)ptr, val, block_w);
-                ptr += (stride * bits) >> 3;
-            }
-        }
-    }
-    GraphicBufferMapper::getInstance().unlock(handle);
-
-    return NO_ERROR;
-}
-
-int GraphicBufferUtil::getRealFormat(buffer_handle_t handle, PixelFormat* format) {
-    if (NULL == handle)
-    {
-        ALOGE("[%s] invalid argument", __func__);
-        return GRALLOC_EXTRA_ERROR;
-    }
-    if (NULL == format)
-    {
-        ALOGE("[%s] invalid argument", __func__);
-        return GRALLOC_EXTRA_ERROR;
-    }
-    int err = GRALLOC_EXTRA_OK;
-
-    // for HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED
-    if ((err = GraphicBufferExtra::get().query(
-                    handle,
-                    GRALLOC_EXTRA_GET_FORMAT,
-                    format)) != GRALLOC_EXTRA_OK)
-    {
-        ALOGE("[%s] to get format failed", __func__);
-        return err;
-    }
-
-    if (HAL_PIXEL_FORMAT_YUV_PRIVATE == *format)
-    {
-        gralloc_extra_ion_sf_info_t sf_info;
-        if ((err = gralloc_extra_query(handle, GRALLOC_EXTRA_GET_IOCTL_ION_SF_INFO, &sf_info))
-                != GRALLOC_EXTRA_OK) {
-            ALOGE("[%s] to query real format failed", __func__);
-            return err;
-        }
-        // check real format within private format
-        switch (sf_info.status & GRALLOC_EXTRA_MASK_CM)
-        {
-            case GRALLOC_EXTRA_BIT_CM_YV12:
-                *format = HAL_PIXEL_FORMAT_YV12;
-                break;
-            case GRALLOC_EXTRA_BIT_CM_NV12_BLK:
-                *format = HAL_PIXEL_FORMAT_NV12_BLK;
-                break;
-            case GRALLOC_EXTRA_BIT_CM_NV12_BLK_FCM:
-                *format = HAL_PIXEL_FORMAT_NV12_BLK_FCM;
-                break;
-            default:
-                ALOGE("    CANNOT get real format: (format=0x%x, fillFormat=0x%x)",
-                      *format,
-                      sf_info.status & GRALLOC_EXTRA_MASK_CM);
-                return GRALLOC_EXTRA_ERROR;
-        }
-    }
-    return err;
-}
-
-// ---------------------------------------------------------------------------
-}; // namespace android
diff --git a/ui_ext/lib/IDumpTunnel.cpp b/ui_ext/lib/IDumpTunnel.cpp
deleted file mode 100755
index ae53422..0000000
--- a/ui_ext/lib/IDumpTunnel.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-#define LOG_TAG "DumpTunnel"
-
-#define MTK_LOG_ENABLE 1
-#include <dlfcn.h>
-#include <utils/String8.h>
-#include <binder/Parcel.h>
-#include <cutils/log.h>
-#include <IDumpTunnel.h>
-
-namespace android {
-
-// client : proxy GuiEx class
-class BpDumpTunnel : public BpInterface<IDumpTunnel> {
-public:
-    BpDumpTunnel(const sp<IBinder>& impl)
-        :   BpInterface<IDumpTunnel>(impl) {
-    }
-
-    virtual status_t kickDump(String8& result, const char* prefix) {
-        Parcel data, reply;
-        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
-        data.writeString8(result);
-        data.writeCString(prefix);
-        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
-        if (err != NO_ERROR) {
-            ALOGE("kickDump could not contact remote\n");
-            return err;
-        }
-        result = reply.readString8();
-        err = reply.readInt32();
-        return err;
-    }
-};
-
-IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
-
-status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
-    switch (code) {
-        case DUMPTUNNEL_DUMP: {
-            CHECK_INTERFACE(IDumpTunnel, data, reply);
-            String8 result;
-            const char* prefix = NULL;
-            result = data.readString8();
-            prefix = data.readCString();
-
-            status_t ret = kickDump(result, prefix);
-            reply->writeString8(result);
-            reply->writeInt32(ret);
-            return NO_ERROR;
-        } break;
-    }
-    return BBinder::onTransact(code, data, reply, flags);
-}
-
-// ----------------------------------------------------------------------------
-
-ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
-
-DumpTunnelHelper::DumpTunnelHelper() :
-    mSoHandle(NULL),
-    mRegDumpPtr(NULL),
-    mUnregDumpPtr(NULL)
-{
-    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
-    typedef bool (*UnregDumpPrototype)(const String8&);
-
-    // dlopen must set RTLD_LAZY flag because of performance issue
-    // need to use different path for 32/64 env
-#ifdef __LP64__
-    mSoHandle = dlopen("/system/lib64/libgui_ext.so", RTLD_LAZY);
-#else
-    mSoHandle = dlopen("/system/lib/libgui_ext.so", RTLD_LAZY);
-#endif
-    if (mSoHandle) {
-        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
-        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
-        if (NULL == mRegDumpPtr) {
-            ALOGE("finding regDump() failed");
-        }
-        if (NULL == mUnregDumpPtr) {
-            ALOGE("finding unregDump() failed");
-        }
-    } else {
-        ALOGE("open libgui_ext failed");
-    }
-}
-
-DumpTunnelHelper::~DumpTunnelHelper() {
-    if(mSoHandle != NULL)
-        dlclose(mSoHandle);
-}
-
-bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
-    bool result = false;
-    if (NULL == mRegDumpPtr) {
-        ALOGE("finding regDump() failed");
-        return result;
-    }
-    result = mRegDumpPtr(tunnel, key);
-
-    return result;
-}
-
-bool DumpTunnelHelper::unregDump(const String8& key) {
-    bool result = false;
-    if (NULL == mUnregDumpPtr) {
-        ALOGE("finding unregDump() failed");
-        return result;
-    }
-    result = mUnregDumpPtr(key);
-
-    return result;
-}
-
-};
diff --git a/ui_ext/lib/NOTICE b/ui_ext/lib/NOTICE
deleted file mode 100755
index 0519ecb..0000000
--- a/ui_ext/lib/NOTICE
+++ /dev/null
@@ -1 +0,0 @@
- 
\ No newline at end of file
diff --git a/ui_ext/lib/README b/ui_ext/lib/README
deleted file mode 100755
index bf0a97a..0000000
--- a/ui_ext/lib/README
+++ /dev/null
@@ -1,31 +0,0 @@
-This directory contains some utilities functions
-
-WHAT IT DOES?
-=============
-
-The library implements some utilties function for debugging
-
-
-HOW IT WAS BUILT?
-==================
-
-It needs the following libs from AOSP:
-1.  libpng.so
-2.  libutils.so
-3.  libui.so
-4.  libcutils.so
-5.  libhardware.so
-
-and the following libs from MediaTek:
-4.  libgralloc_extra.so
-
-All source/dependency modules of this module are already put in
-'vendor/mediatek/proprietary/hardware/ui_ext/lib' folder.
-
-
-HOW TO USE IT?
-==============
-
-just link the libui_ext.so
-
-All the source code of this library were written by MediaTek co..
diff --git a/ui_ext/lib/RefBaseDump.cpp b/ui_ext/lib/RefBaseDump.cpp
deleted file mode 100755
index b9477af..0000000
--- a/ui_ext/lib/RefBaseDump.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-#define LOG_TAG "RefBaseDump"
-
-#if 0
-#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
-#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
-#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
-#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
-#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
-#else
-#define RBD_LOGV(x, ...)
-#define RBD_LOGD(x, ...)
-#define RBD_LOGI(x, ...)
-#define RBD_LOGW(x, ...)
-#define RBD_LOGE(x, ...)
-#endif
-
-#include <cutils/log.h>
-#include <cutils/process_name.h>
-#include <cutils/properties.h>
-#include <RefBaseDump.h>
-
-namespace android {
-
-//-------------------------------------------------------------------------
-// RefBaseDump
-//-------------------------------------------------------------------------
-
-RefBaseDump::RefBaseDump(RefBaseMonitor* pMonitor)
-    : mMonitor(pMonitor) {
-}
-
-RefBaseDump::~RefBaseDump() {
-}
-
-status_t RefBaseDump::kickDump(String8& result, const char* prefix) {
-    return mMonitor->dump(result);
-}
-
-//-------------------------------------------------------------------------
-// RefBaseMonitor
-//-------------------------------------------------------------------------
-
-ANDROID_SINGLETON_STATIC_INSTANCE(RefBaseMonitor)
-
-RefBaseMonitor::RefBaseMonitor() {
-    char value[PROPERTY_VALUE_MAX];
-    RBD_LOGI("RefBaseMonitor ctor - %p", this);
-    getProcessName();
-    property_get("debug.rb.dump", value, "Mary had a little lamb");
-    mIsTracking = (-1 != mProcessName.find(value));
-    mDump = new RefBaseDump(this);
-    DumpTunnelHelper::getInstance().regDump(mDump, String8::format("RB-%p", this));
-}
-
-RefBaseMonitor::~RefBaseMonitor() {
-    RBD_LOGI("RefBaseMonitor dtor - %p", this);
-    DumpTunnelHelper::getInstance().unregDump(String8::format("RB-%p", this));
-}
-
-status_t RefBaseMonitor::monitor(RefBase *pRb) {
-    Mutex::Autolock _l(mMutex);
-    if (mIsTracking) {
-        pRb->trackMe(true, false);
-    }
-    RbList.add(pRb, 0);
-    return NO_ERROR;
-}
-
-status_t RefBaseMonitor::unmonitor(RefBase *pRb) {
-    Mutex::Autolock _l(mMutex);
-    RbList.removeItem(pRb);
-    return NO_ERROR;
-}
-
-status_t RefBaseMonitor::dump(String8& result) {
-    int listSz;
-    RefBase *pRb;
-    Mutex::Autolock _l(mMutex);
-    RBD_LOGI("RefBaseMonitor Dump - %p", this);
-    listSz = RbList.size();
-    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
-    result.append(mIsTracking ? " <- tracking\n" : "\n");
-    result.append("\t  -----------------------\n");
-
-    for (int i = 0; i < listSz; i++) {
-        pRb = RbList.keyAt(i);
-        if (mIsTracking) {
-            pRb->printRefs();
-        }
-        result.appendFormat("\t   %2d) %8p %4d\n", i, pRb, pRb->getStrongCount());
-    }
-    result.append("\t*****************************************************\n");
-    return NO_ERROR;
-}
-
-status_t RefBaseMonitor::getProcessName() {
-    int pid = getpid();
-    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
-    if (NULL != fp) {
-        const size_t size = 64;
-        char proc_name[size];
-        fgets(proc_name, size, fp);
-        fclose(fp);
-        mProcessName = proc_name;
-    } else {
-        mProcessName = "unknownProcess";
-    }
-    return NO_ERROR;
-}
-
-}
diff --git a/vendorsetup.sh b/vendorsetup.sh
index cae2b98..7e31bb4 100644
--- a/vendorsetup.sh
+++ b/vendorsetup.sh
@@ -14,13 +14,4 @@
 # limitations under the License.
 #
 
-# This file is executed by build/envsetup.sh, and can use anything
-# defined in envsetup.sh.
-#
-# In particular, you can add lunch options with the add_lunch_combo
-# function: add_lunch_combo generic-eng
-
-for var in eng user userdebug; do
-  add_lunch_combo lineage_apollo_lite-$var
-done
-
+add_lunch_combo lineage_apollo_lite-userdebug
